// Package api_v0 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api_v0

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for EgressMode.
const (
	Snapshot EgressMode = "snapshot"
	Watch    EgressMode = "watch"
)

// Defines values for JsonUpdateFormat.
const (
	Debezium     JsonUpdateFormat = "debezium"
	InsertDelete JsonUpdateFormat = "insert_delete"
	Raw          JsonUpdateFormat = "raw"
	Snowflake    JsonUpdateFormat = "snowflake"
	Weighted     JsonUpdateFormat = "weighted"
)

// Defines values for OutputQuery.
const (
	Neighborhood OutputQuery = "neighborhood"
	Quantiles    OutputQuery = "quantiles"
	Table        OutputQuery = "table"
)

// Defines values for PipelineStatus.
const (
	Failed       PipelineStatus = "Failed"
	Initializing PipelineStatus = "Initializing"
	Paused       PipelineStatus = "Paused"
	Provisioning PipelineStatus = "Provisioning"
	Running      PipelineStatus = "Running"
	Shutdown     PipelineStatus = "Shutdown"
	ShuttingDown PipelineStatus = "ShuttingDown"
)

// Defines values for ProgramStatus0.
const (
	None ProgramStatus0 = "None"
)

// Defines values for ProgramStatus1.
const (
	Pending ProgramStatus1 = "Pending"
)

// Defines values for ProgramStatus2.
const (
	CompilingSql ProgramStatus2 = "CompilingSql"
)

// Defines values for ProgramStatus3.
const (
	CompilingRust ProgramStatus3 = "CompilingRust"
)

// Defines values for ProgramStatus4.
const (
	Success ProgramStatus4 = "Success"
)

// AttachedConnector Format to add attached connectors during a config update.
type AttachedConnector struct {
	// ConnectorId Unique connector id.
	ConnectorId ConnectorId `json:"connector_id"`

	// IsInput Is this an input or an output?
	IsInput bool `json:"is_input"`

	// Name A unique identifier for this attachement.
	Name string `json:"name"`

	// RelationName The table or view this connector is attached to.
	RelationName string `json:"relation_name"`
}

// AuthProvider defines model for AuthProvider.
type AuthProvider struct {
	union json.RawMessage
}

// AuthProvider0 defines model for .
type AuthProvider0 struct {
	AwsCognito ProviderAwsCognito `json:"AwsCognito"`
}

// AuthProvider1 defines model for .
type AuthProvider1 struct {
	GoogleIdentity ProviderGoogleIdentity `json:"GoogleIdentity"`
}

// Chunk A set of updates to a SQL table or view.
//
// The `sequence_number` field stores the offset of the chunk relative to the
// start of the stream and can be used to implement reliable delivery.
// The payload is stored in the `bin_data`, `text_data`, or `json_data` field
// depending on the data format used.
type Chunk struct {
	// BinData Base64 encoded binary payload, e.g., bincode.
	BinData *openapi_types.File `json:"bin_data"`

	// JsonData JSON payload.
	JsonData       *map[string]interface{} `json:"json_data"`
	SequenceNumber int64                   `json:"sequence_number"`

	// TextData Text payload, e.g., CSV.
	TextData *string `json:"text_data"`
}

// ColumnType A SQL column type description.
//
// Matches the Calcite JSON format.
type ColumnType struct {
	Component *ColumnType `json:"component"`

	// Nullable Does the type accept NULL values?
	Nullable bool `json:"nullable"`

	// Precision Precision of the type.
	//
	// # Examples
	// - `VARCHAR` sets precision to `-1`.
	// - `VARCHAR(255)` sets precision to `255`.
	// - `BIGINT`, `DATE`, `FLOAT`, `DOUBLE`, `GEOMETRY`, etc. sets precision
	// to None
	// - `TIME`, `TIMESTAMP` set precision to `0`.
	Precision *int64 `json:"precision"`

	// Scale The scale of the type.
	//
	// # Example
	// - `DECIMAL(1,2)` sets scale to `2`.
	Scale *int64 `json:"scale"`

	// Type Identifier for the type (e.g., `VARCHAR`, `BIGINT`, `ARRAY` etc.)
	Type string `json:"type"`
}

// CompileProgramRequest Request to queue a program for compilation.
type CompileProgramRequest struct {
	// Version Version number.
	Version Version `json:"version"`
}

// ConnectorConfig A data connector's configuration
type ConnectorConfig struct {
	// Format Data format specification used to parse raw data received from the
	// endpoint or to encode data sent to the endpoint.
	Format FormatConfig `json:"format"`

	// MaxBufferedRecords Backpressure threshold.
	//
	// Maximal amount of records buffered by the endpoint before the endpoint
	// is paused by the backpressure mechanism.  Note that this is not a
	// hard bound: there can be a small delay between the backpressure
	// mechanism is triggered and the endpoint is paused, during which more
	// data may be received.
	//
	// The default is 1 million.
	MaxBufferedRecords *int64 `json:"max_buffered_records,omitempty"`

	// Transport Transport endpoint configuration.
	Transport TransportConfig `json:"transport"`
}

// ConnectorDescr Connector descriptor.
type ConnectorDescr struct {
	// Config A data connector's configuration
	Config ConnectorConfig `json:"config"`

	// ConnectorId Unique connector id.
	ConnectorId ConnectorId `json:"connector_id"`
	Description string      `json:"description"`
	Name        string      `json:"name"`
}

// ConnectorId Unique connector id.
type ConnectorId = openapi_types.UUID

// EgressMode defines model for EgressMode.
type EgressMode string

// ErrorResponse Information returned by REST API endpoints on error.
type ErrorResponse struct {
	// Details Detailed error metadata.
	// The contents of this field is determined by `error_code`.
	Details map[string]interface{} `json:"details"`

	// ErrorCode Error code is a string that specifies this error type.
	ErrorCode string `json:"error_code"`

	// Message Human-readable error message.
	Message string `json:"message"`
}

// Field A SQL field.
//
// Matches the Calcite JSON format.
type Field struct {
	// Columntype A SQL column type description.
	//
	// Matches the Calcite JSON format.
	Columntype ColumnType `json:"columntype"`
	Name       string     `json:"name"`
}

// FormatConfig Data format specification used to parse raw data received from the
// endpoint or to encode data sent to the endpoint.
type FormatConfig struct {
	// Config Format-specific parser or encoder configuration.
	Config *map[string]interface{} `json:"config,omitempty"`

	// Name Format name, e.g., "csv", "json", "bincode", etc.
	Name string `json:"name"`
}

// InputEndpointConfig defines model for InputEndpointConfig.
type InputEndpointConfig struct {
	// Format Data format specification used to parse raw data received from the
	// endpoint or to encode data sent to the endpoint.
	Format FormatConfig `json:"format"`

	// MaxBufferedRecords Backpressure threshold.
	//
	// Maximal amount of records buffered by the endpoint before the endpoint
	// is paused by the backpressure mechanism.  Note that this is not a
	// hard bound: there can be a small delay between the backpressure
	// mechanism is triggered and the endpoint is paused, during which more
	// data may be received.
	//
	// The default is 1 million.
	MaxBufferedRecords *int64 `json:"max_buffered_records,omitempty"`

	// Stream The name of the input stream of the circuit that this endpoint is
	// connected to.
	Stream string `json:"stream"`

	// Transport Transport endpoint configuration.
	Transport TransportConfig `json:"transport"`
}

// JsonUpdateFormat Supported JSON data change event formats.
//
// Each element in a JSON-formatted input stream specifies
// an update to one or more records in an input table.  We support
// several different ways to represent such updates.
type JsonUpdateFormat string

// NeighborhoodQuery A request to output a specific neighborhood of a table or view.
// The neighborhood is defined in terms of its central point (`anchor`)
// and the number of rows preceding and following the anchor to output.
type NeighborhoodQuery struct {
	After  int32                   `json:"after"`
	Anchor *map[string]interface{} `json:"anchor"`
	Before int32                   `json:"before"`
}

// NewConnectorRequest Request to create a new connector.
type NewConnectorRequest struct {
	// Config A data connector's configuration
	Config ConnectorConfig `json:"config"`

	// Description Connector description.
	Description string `json:"description"`

	// Name Connector name.
	Name string `json:"name"`
}

// NewConnectorResp Response to a connector creation request.
type NewConnectorResp struct {
	// ConnectorId Unique connector id.
	ConnectorId ConnectorId `json:"connector_id"`
}

// NewPipelineRequest Request to create a new pipeline.
type NewPipelineRequest struct {
	// Config Global pipeline configuration settings.
	Config RuntimeConfig `json:"config"`

	// Connectors Attached connectors.
	Connectors *[]AttachedConnector `json:"connectors"`

	// Description Config description.
	Description string `json:"description"`

	// Name Config name.
	Name      string     `json:"name"`
	ProgramId *ProgramId `json:"program_id"`
}

// NewPipelineResp Response to a pipeline creation request.
type NewPipelineResp struct {
	// PipelineId Unique pipeline id.
	PipelineId PipelineId `json:"pipeline_id"`

	// Version Version number.
	Version Version `json:"version"`
}

// NewProgramRequest Request to create a new DBSP program.
type NewProgramRequest struct {
	// Code SQL code of the program.
	Code string `json:"code"`

	// Description Program description.
	Description string `json:"description"`

	// Name Program name.
	Name string `json:"name"`
}

// NewProgramResp Response to a new program request.
type NewProgramResp struct {
	// ProgramId Unique program id.
	ProgramId ProgramId `json:"program_id"`

	// Version Version number.
	Version Version `json:"version"`
}

// OutputEndpointConfig defines model for OutputEndpointConfig.
type OutputEndpointConfig struct {
	// Format Data format specification used to parse raw data received from the
	// endpoint or to encode data sent to the endpoint.
	Format FormatConfig `json:"format"`

	// MaxBufferedRecords Backpressure threshold.
	//
	// Maximal amount of records buffered by the endpoint before the endpoint
	// is paused by the backpressure mechanism.  Note that this is not a
	// hard bound: there can be a small delay between the backpressure
	// mechanism is triggered and the endpoint is paused, during which more
	// data may be received.
	//
	// The default is 1 million.
	MaxBufferedRecords *int64 `json:"max_buffered_records,omitempty"`

	// Stream The name of the output stream of the circuit that this endpoint is
	// connected to.
	Stream string `json:"stream"`

	// Transport Transport endpoint configuration.
	Transport TransportConfig `json:"transport"`
}

// OutputQuery A query over an output stream.
//
// We currently do not support ad hoc queries.  Instead the client can use
// three pre-defined queries to inspect the contents of a table or view.
type OutputQuery string

// Pipeline State of a pipeline, including static configuration
// and runtime status.
type Pipeline struct {
	// Descriptor Pipeline descriptor.
	Descriptor PipelineDescr `json:"descriptor"`

	// State Runtime state of the pipeine.
	State PipelineRuntimeState `json:"state"`
}

// PipelineConfig defines model for PipelineConfig.
type PipelineConfig struct {
	// CpuProfiler Enable CPU profiler.
	CpuProfiler *bool `json:"cpu_profiler,omitempty"`

	// Inputs Input endpoint configuration.
	Inputs map[string]InputEndpointConfig `json:"inputs"`

	// MaxBufferingDelayUsecs Maximal delay in microseconds to wait for `min_batch_size_records` to
	// get buffered by the controller, defaults to 0.
	MaxBufferingDelayUsecs *int64 `json:"max_buffering_delay_usecs,omitempty"`

	// MinBatchSizeRecords Minimal input batch size.
	//
	// The controller delays pushing input records to the circuit until at
	// least `min_batch_size_records` records have been received (total
	// across all endpoints) or `max_buffering_delay_usecs` microseconds
	// have passed since at least one input records has been buffered.
	// Defaults to 0.
	MinBatchSizeRecords *int64 `json:"min_batch_size_records,omitempty"`

	// Name Pipeline name
	Name *string `json:"name"`

	// Outputs Output endpoint configuration.
	Outputs *map[string]OutputEndpointConfig `json:"outputs,omitempty"`

	// Workers Number of DBSP worker threads.
	Workers *int32 `json:"workers,omitempty"`
}

// PipelineDescr Pipeline descriptor.
type PipelineDescr struct {
	AttachedConnectors []AttachedConnector `json:"attached_connectors"`

	// Config Global pipeline configuration settings.
	Config      RuntimeConfig `json:"config"`
	Description string        `json:"description"`
	Name        string        `json:"name"`

	// PipelineId Unique pipeline id.
	PipelineId PipelineId `json:"pipeline_id"`
	ProgramId  *ProgramId `json:"program_id"`

	// Version Version number.
	Version Version `json:"version"`
}

// PipelineId Unique pipeline id.
type PipelineId = openapi_types.UUID

// PipelineRevision A pipeline revision is a versioned, immutable configuration struct that
// contains all information necessary to run a pipeline.
type PipelineRevision struct {
	// Config Pipeline configuration specified by the user when creating
	// a new pipeline instance.
	Config PipelineConfig `json:"config"`

	// Connectors The versioned connectors.
	Connectors []ConnectorDescr `json:"connectors"`

	// Pipeline Pipeline descriptor.
	Pipeline PipelineDescr `json:"pipeline"`

	// Program Program descriptor.
	Program ProgramDescr `json:"program"`

	// Revision Revision number.
	Revision Revision `json:"revision"`
}

// PipelineRuntimeState Runtime state of the pipeine.
type PipelineRuntimeState struct {
	// Created Time when the pipeline started executing.
	Created time.Time `json:"created"`

	// CurrentStatus Pipeline status.
	//
	// This type represents the state of the pipeline tracked by the pipeline
	// runner and observed by the API client via the `GET /pipeline` endpoint.
	//
	// ### The lifecycle of a pipeline
	//
	// The following automaton captures the lifecycle of the pipeline.  Individual
	// states and transitions of the automaton are described below.
	//
	// * In addition to the transitions shown in the diagram, all states have an
	// implicit "forced shutdown" transition to the `Shutdown` state.  This
	// transition is triggered when the pipeline runner is unable to communicate
	// with the pipeline and thereby forces a shutdown.
	//
	// * States labeled with the hourglass symbol (⌛) are **timed** states.  The
	// automaton stays in timed state until the corresponding operation completes
	// or until the runner performs a forced shutdown of the pipeline after a
	// pre-defined timeout perioud.
	//
	// * State transitions labeled with API endpoint names (`/deploy`, `/start`,
	// `/pause`, `/shutdown`) are triggered by invoking corresponding endpoint,
	// e.g., `POST /v0/pipelines/{pipeline_id}/start`.
	//
	// ```text
	// Shutdown◄────┐
	// │         │
	// /deploy│         │
	// │   ⌛ShuttingDown
	// ▼         ▲
	// ⌛Provisioning    │
	// │         │
	// Provisioned        │         │
	// ▼         │/shutdown
	// ⌛Initializing    │
	// │         │
	// ┌────────┴─────────┴─┐
	// │        ▼           │
	// │      Paused        │
	// │      │    ▲        │
	// │/start│    │/pause  │
	// │      ▼    │        │
	// │     Running        │
	// └──────────┬─────────┘
	// │
	// ▼
	// Failed
	// ```
	//
	// ### Desired and actual status
	//
	// We use the desired state model to manage the lifecycle of a pipeline.
	// In this model, the pipeline has two status attributes associated with
	// it at runtime: the **desired** status, which represents what the user
	// would like the pipeline to do, and the **current** status, which
	// represents the actual state of the pipeline.  The pipeline runner
	// service continuously monitors both fields and steers the pipeline
	// towards the desired state specified by the user.
	// Only three of the states in the pipeline automaton above can be
	// used as desired statuses: `Paused`, `Running`, and `Shutdown`.
	// These statuses are selected by invoking REST endpoints shown
	// in the diagram.
	//
	// The user can monitor the current state of the pipeline via the
	// `/status` endpoint, which returns an object of type [`Pipeline`].
	// In a typical scenario, the user first sets
	// the desired state, e.g., by invoking the `/deploy` endpoint, and
	// then polls the `GET /pipeline` endpoint to monitor the actual status
	// of the pipeline until its `state.current_status` attribute changes
	// to "paused" indicating that the pipeline has been successfully
	// initialized, or "failed", indicating an error.
	CurrentStatus PipelineStatus `json:"current_status"`

	// DesiredStatus Pipeline status.
	//
	// This type represents the state of the pipeline tracked by the pipeline
	// runner and observed by the API client via the `GET /pipeline` endpoint.
	//
	// ### The lifecycle of a pipeline
	//
	// The following automaton captures the lifecycle of the pipeline.  Individual
	// states and transitions of the automaton are described below.
	//
	// * In addition to the transitions shown in the diagram, all states have an
	// implicit "forced shutdown" transition to the `Shutdown` state.  This
	// transition is triggered when the pipeline runner is unable to communicate
	// with the pipeline and thereby forces a shutdown.
	//
	// * States labeled with the hourglass symbol (⌛) are **timed** states.  The
	// automaton stays in timed state until the corresponding operation completes
	// or until the runner performs a forced shutdown of the pipeline after a
	// pre-defined timeout perioud.
	//
	// * State transitions labeled with API endpoint names (`/deploy`, `/start`,
	// `/pause`, `/shutdown`) are triggered by invoking corresponding endpoint,
	// e.g., `POST /v0/pipelines/{pipeline_id}/start`.
	//
	// ```text
	// Shutdown◄────┐
	// │         │
	// /deploy│         │
	// │   ⌛ShuttingDown
	// ▼         ▲
	// ⌛Provisioning    │
	// │         │
	// Provisioned        │         │
	// ▼         │/shutdown
	// ⌛Initializing    │
	// │         │
	// ┌────────┴─────────┴─┐
	// │        ▼           │
	// │      Paused        │
	// │      │    ▲        │
	// │/start│    │/pause  │
	// │      ▼    │        │
	// │     Running        │
	// └──────────┬─────────┘
	// │
	// ▼
	// Failed
	// ```
	//
	// ### Desired and actual status
	//
	// We use the desired state model to manage the lifecycle of a pipeline.
	// In this model, the pipeline has two status attributes associated with
	// it at runtime: the **desired** status, which represents what the user
	// would like the pipeline to do, and the **current** status, which
	// represents the actual state of the pipeline.  The pipeline runner
	// service continuously monitors both fields and steers the pipeline
	// towards the desired state specified by the user.
	// Only three of the states in the pipeline automaton above can be
	// used as desired statuses: `Paused`, `Running`, and `Shutdown`.
	// These statuses are selected by invoking REST endpoints shown
	// in the diagram.
	//
	// The user can monitor the current state of the pipeline via the
	// `/status` endpoint, which returns an object of type [`Pipeline`].
	// In a typical scenario, the user first sets
	// the desired state, e.g., by invoking the `/deploy` endpoint, and
	// then polls the `GET /pipeline` endpoint to monitor the actual status
	// of the pipeline until its `state.current_status` attribute changes
	// to "paused" indicating that the pipeline has been successfully
	// initialized, or "failed", indicating an error.
	DesiredStatus PipelineStatus `json:"desired_status"`
	Error         *ErrorResponse `json:"error"`

	// Location Location where the pipeline can be reached at runtime.
	// e.g., a TCP port number or a URI.
	Location string `json:"location"`

	// StatusSince Time when the pipeline was assigned its current status
	// of the pipeline.
	StatusSince time.Time `json:"status_since"`
}

// PipelineStatus Pipeline status.
//
// This type represents the state of the pipeline tracked by the pipeline
// runner and observed by the API client via the `GET /pipeline` endpoint.
//
// ### The lifecycle of a pipeline
//
// The following automaton captures the lifecycle of the pipeline.  Individual
// states and transitions of the automaton are described below.
//
// * In addition to the transitions shown in the diagram, all states have an
// implicit "forced shutdown" transition to the `Shutdown` state.  This
// transition is triggered when the pipeline runner is unable to communicate
// with the pipeline and thereby forces a shutdown.
//
// * States labeled with the hourglass symbol (⌛) are **timed** states.  The
// automaton stays in timed state until the corresponding operation completes
// or until the runner performs a forced shutdown of the pipeline after a
// pre-defined timeout perioud.
//
// * State transitions labeled with API endpoint names (`/deploy`, `/start`,
// `/pause`, `/shutdown`) are triggered by invoking corresponding endpoint,
// e.g., `POST /v0/pipelines/{pipeline_id}/start`.
//
// ```text
// Shutdown◄────┐
// │         │
// /deploy│         │
// │   ⌛ShuttingDown
// ▼         ▲
// ⌛Provisioning    │
// │         │
// Provisioned        │         │
// ▼         │/shutdown
// ⌛Initializing    │
// │         │
// ┌────────┴─────────┴─┐
// │        ▼           │
// │      Paused        │
// │      │    ▲        │
// │/start│    │/pause  │
// │      ▼    │        │
// │     Running        │
// └──────────┬─────────┘
// │
// ▼
// Failed
// ```
//
// ### Desired and actual status
//
// We use the desired state model to manage the lifecycle of a pipeline.
// In this model, the pipeline has two status attributes associated with
// it at runtime: the **desired** status, which represents what the user
// would like the pipeline to do, and the **current** status, which
// represents the actual state of the pipeline.  The pipeline runner
// service continuously monitors both fields and steers the pipeline
// towards the desired state specified by the user.
// Only three of the states in the pipeline automaton above can be
// used as desired statuses: `Paused`, `Running`, and `Shutdown`.
// These statuses are selected by invoking REST endpoints shown
// in the diagram.
//
// The user can monitor the current state of the pipeline via the
// `/status` endpoint, which returns an object of type [`Pipeline`].
// In a typical scenario, the user first sets
// the desired state, e.g., by invoking the `/deploy` endpoint, and
// then polls the `GET /pipeline` endpoint to monitor the actual status
// of the pipeline until its `state.current_status` attribute changes
// to "paused" indicating that the pipeline has been successfully
// initialized, or "failed", indicating an error.
type PipelineStatus string

// ProgramDescr Program descriptor.
type ProgramDescr struct {
	// Code SQL code
	Code *string `json:"code"`

	// Description Program description.
	Description string `json:"description"`

	// Name Program name (doesn't have to be unique).
	Name string `json:"name"`

	// ProgramId Unique program id.
	ProgramId ProgramId      `json:"program_id"`
	Schema    *ProgramSchema `json:"schema"`

	// Status Program compilation status.
	Status ProgramStatus `json:"status"`

	// Version Version number.
	Version Version `json:"version"`
}

// ProgramId Unique program id.
type ProgramId = openapi_types.UUID

// ProgramSchema A struct containting the tables (inputs) and views for a program.
//
// Parse from the JSON data-type of the DDL generated by the SQL compiler.
type ProgramSchema struct {
	Inputs  []Relation `json:"inputs"`
	Outputs []Relation `json:"outputs"`
}

// ProgramStatus Program compilation status.
type ProgramStatus struct {
	union json.RawMessage
}

// ProgramStatus0 Initial state: program has been created or modified, but the user
// hasn't yet started compiling the program.
type ProgramStatus0 string

// ProgramStatus1 Compilation request received from the user; program has been placed
// in the queue.
type ProgramStatus1 string

// ProgramStatus2 Compilation of SQL -> Rust in progress.
type ProgramStatus2 string

// ProgramStatus3 Compiling Rust -> executable in progress
type ProgramStatus3 string

// ProgramStatus4 Compilation succeeded.
type ProgramStatus4 string

// ProgramStatus5 defines model for .
type ProgramStatus5 struct {
	// SqlError SQL compiler returned an error.
	SqlError []SqlCompilerMessage `json:"SqlError"`
}

// ProgramStatus6 defines model for .
type ProgramStatus6 struct {
	// RustError Rust compiler returned an error.
	RustError string `json:"RustError"`
}

// ProgramStatus7 defines model for .
type ProgramStatus7 struct {
	// SystemError System/OS returned an error when trying to invoke commands.
	SystemError string `json:"SystemError"`
}

// ProviderAwsCognito defines model for ProviderAwsCognito.
type ProviderAwsCognito struct {
	JwkUri    string `json:"jwk_uri"`
	LoginUrl  string `json:"login_url"`
	LogoutUrl string `json:"logout_url"`
}

// ProviderGoogleIdentity defines model for ProviderGoogleIdentity.
type ProviderGoogleIdentity struct {
	ClientId string `json:"client_id"`
	JwkUri   string `json:"jwk_uri"`
}

// Relation A SQL table or view. It has a name and a list of fields.
//
// Matches the Calcite JSON format.
type Relation struct {
	Fields []Field `json:"fields"`
	Name   string  `json:"name"`
}

// Revision Revision number.
type Revision = openapi_types.UUID

// RuntimeConfig Global pipeline configuration settings.
type RuntimeConfig struct {
	// CpuProfiler Enable CPU profiler.
	CpuProfiler *bool `json:"cpu_profiler,omitempty"`

	// MaxBufferingDelayUsecs Maximal delay in microseconds to wait for `min_batch_size_records` to
	// get buffered by the controller, defaults to 0.
	MaxBufferingDelayUsecs *int64 `json:"max_buffering_delay_usecs,omitempty"`

	// MinBatchSizeRecords Minimal input batch size.
	//
	// The controller delays pushing input records to the circuit until at
	// least `min_batch_size_records` records have been received (total
	// across all endpoints) or `max_buffering_delay_usecs` microseconds
	// have passed since at least one input records has been buffered.
	// Defaults to 0.
	MinBatchSizeRecords *int64 `json:"min_batch_size_records,omitempty"`

	// Workers Number of DBSP worker threads.
	Workers *int32 `json:"workers,omitempty"`
}

// SqlCompilerMessage A SQL compiler error.
//
// The SQL compiler returns a list of errors in the following JSON format if
// it's invoked with the `-je` option.
//
// ```ignore
// [ {
// "startLineNumber" : 14,
// "startColumn" : 13,
// "endLineNumber" : 14,
// "endColumn" : 13,
// "warning" : false,
// "errorType" : "Error parsing SQL",
// "message" : "Encountered \"<EOF>\" at line 14, column 13."
// } ]
// ```
type SqlCompilerMessage struct {
	EndColumn       int    `json:"endColumn"`
	EndLineNumber   int    `json:"endLineNumber"`
	ErrorType       string `json:"errorType"`
	Message         string `json:"message"`
	StartColumn     int    `json:"startColumn"`
	StartLineNumber int    `json:"startLineNumber"`
	Warning         bool   `json:"warning"`
}

// TransportConfig Transport endpoint configuration.
type TransportConfig struct {
	// Config Transport-specific endpoint configuration passed to
	// `crate::OutputTransport::new_endpoint`
	// and `crate::InputTransport::new_endpoint`.
	Config *map[string]interface{} `json:"config,omitempty"`

	// Name Data transport name, e.g., `file`, `kafka`, `kinesis`
	Name string `json:"name"`
}

// UpdateConnectorRequest Request to update an existing data-connector.
type UpdateConnectorRequest struct {
	Config *ConnectorConfig `json:"config"`

	// Description New connector description.
	Description string `json:"description"`

	// Name New connector name.
	Name string `json:"name"`
}

// UpdateConnectorResp Response to a config update request.
type UpdateConnectorResp = map[string]interface{}

// UpdatePipelineRequest Request to update an existing pipeline.
type UpdatePipelineRequest struct {
	Config *RuntimeConfig `json:"config"`

	// Connectors Attached connectors.
	//
	// - If absent, existing connectors will be kept unmodified.
	//
	// - If present all existing connectors will be replaced with the new
	// specified list.
	Connectors *[]AttachedConnector `json:"connectors"`

	// Description New pipeline description.
	Description string `json:"description"`

	// Name New pipeline name.
	Name      string     `json:"name"`
	ProgramId *ProgramId `json:"program_id"`
}

// UpdatePipelineResp Response to a config update request.
type UpdatePipelineResp struct {
	// Version Version number.
	Version Version `json:"version"`
}

// UpdateProgramRequest Update program request.
type UpdateProgramRequest struct {
	// Code New SQL code for the program or `None` to keep existing program
	// code unmodified.
	Code *string `json:"code"`

	// Description New description for the program.
	Description *string `json:"description,omitempty"`

	// Name New name for the program.
	Name string `json:"name"`
}

// UpdateProgramResp Response to a program update request.
type UpdateProgramResp struct {
	// Version Version number.
	Version Version `json:"version"`
}

// Version Version number.
type Version = int64

// ListConnectorsParams defines parameters for ListConnectors.
type ListConnectorsParams struct {
	// Id Unique connector identifier.
	Id *openapi_types.UUID `form:"id,omitempty" json:"id,omitempty"`

	// Name Unique connector name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// ListPipelinesParams defines parameters for ListPipelines.
type ListPipelinesParams struct {
	// Id Unique pipeline id.
	Id *openapi_types.UUID `form:"id,omitempty" json:"id,omitempty"`

	// Name Unique pipeline name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// HttpOutputJSONBody defines parameters for HttpOutput.
type HttpOutputJSONBody = NeighborhoodQuery

// HttpOutputParams defines parameters for HttpOutput.
type HttpOutputParams struct {
	// Format Output data format, e.g., 'csv' or 'json'.
	Format string `form:"format" json:"format"`

	// Query Query to execute on the table. Must be one of 'table', 'neighborhood', or 'quantiles'. The default value is 'table'
	Query *OutputQuery `form:"query,omitempty" json:"query,omitempty"`

	// Mode Output mode. Must be one of 'watch' or 'snapshot'. The default value is 'watch'
	Mode *EgressMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Quantiles For 'quantiles' queries: the number of quantiles to output. The default value is 100.
	Quantiles *int32 `form:"quantiles,omitempty" json:"quantiles,omitempty"`

	// Array Set to `true` to group updates in this stream into JSON arrays (used in conjunction with `format=json`). The default value is `false`
	Array *bool `form:"array,omitempty" json:"array,omitempty"`
}

// HttpInputParams defines parameters for HttpInput.
type HttpInputParams struct {
	// Force When `true`, push data to the pipeline even if the pipeline is paused. The default value is `false`
	Force bool `form:"force" json:"force"`

	// Format Input data format, e.g., 'csv' or 'json'.
	Format string `form:"format" json:"format"`

	// Array Set to `true` if updates in this stream are packaged into JSON arrays (used in conjunction with `format=json`). The default values is `false`.
	Array *bool `form:"array,omitempty" json:"array,omitempty"`

	// UpdateFormat JSON data change event format (used in conjunction with `format=json`).  The default value is 'insert_delete'.
	UpdateFormat *JsonUpdateFormat `form:"update_format,omitempty" json:"update_format,omitempty"`
}

// GetProgramsParams defines parameters for GetPrograms.
type GetProgramsParams struct {
	// Id Unique program identifier.
	Id *openapi_types.UUID `form:"id,omitempty" json:"id,omitempty"`

	// Name Unique program name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// WithCode Option to include the SQL program code or not
	// in the Program objects returned by the query.
	// If false (default), the returned program object
	// will not include the code.
	WithCode *bool `form:"with_code,omitempty" json:"with_code,omitempty"`
}

// GetProgramParams defines parameters for GetProgram.
type GetProgramParams struct {
	// WithCode Option to include the SQL program code or not
	// in the Program objects returned by the query.
	// If false (default), the returned program object
	// will not include the code.
	WithCode *bool `form:"with_code,omitempty" json:"with_code,omitempty"`
}

// NewConnectorJSONRequestBody defines body for NewConnector for application/json ContentType.
type NewConnectorJSONRequestBody = NewConnectorRequest

// UpdateConnectorJSONRequestBody defines body for UpdateConnector for application/json ContentType.
type UpdateConnectorJSONRequestBody = UpdateConnectorRequest

// NewPipelineJSONRequestBody defines body for NewPipeline for application/json ContentType.
type NewPipelineJSONRequestBody = NewPipelineRequest

// UpdatePipelineJSONRequestBody defines body for UpdatePipeline for application/json ContentType.
type UpdatePipelineJSONRequestBody = UpdatePipelineRequest

// HttpOutputJSONRequestBody defines body for HttpOutput for application/json ContentType.
type HttpOutputJSONRequestBody = HttpOutputJSONBody

// NewProgramJSONRequestBody defines body for NewProgram for application/json ContentType.
type NewProgramJSONRequestBody = NewProgramRequest

// UpdateProgramJSONRequestBody defines body for UpdateProgram for application/json ContentType.
type UpdateProgramJSONRequestBody = UpdateProgramRequest

// CompileProgramJSONRequestBody defines body for CompileProgram for application/json ContentType.
type CompileProgramJSONRequestBody = CompileProgramRequest

// AsAuthProvider0 returns the union data inside the AuthProvider as a AuthProvider0
func (t AuthProvider) AsAuthProvider0() (AuthProvider0, error) {
	var body AuthProvider0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthProvider0 overwrites any union data inside the AuthProvider as the provided AuthProvider0
func (t *AuthProvider) FromAuthProvider0(v AuthProvider0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthProvider0 performs a merge with any union data inside the AuthProvider, using the provided AuthProvider0
func (t *AuthProvider) MergeAuthProvider0(v AuthProvider0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAuthProvider1 returns the union data inside the AuthProvider as a AuthProvider1
func (t AuthProvider) AsAuthProvider1() (AuthProvider1, error) {
	var body AuthProvider1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthProvider1 overwrites any union data inside the AuthProvider as the provided AuthProvider1
func (t *AuthProvider) FromAuthProvider1(v AuthProvider1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthProvider1 performs a merge with any union data inside the AuthProvider, using the provided AuthProvider1
func (t *AuthProvider) MergeAuthProvider1(v AuthProvider1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AuthProvider) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AuthProvider) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsProgramStatus0 returns the union data inside the ProgramStatus as a ProgramStatus0
func (t ProgramStatus) AsProgramStatus0() (ProgramStatus0, error) {
	var body ProgramStatus0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus0 overwrites any union data inside the ProgramStatus as the provided ProgramStatus0
func (t *ProgramStatus) FromProgramStatus0(v ProgramStatus0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus0 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus0
func (t *ProgramStatus) MergeProgramStatus0(v ProgramStatus0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsProgramStatus1 returns the union data inside the ProgramStatus as a ProgramStatus1
func (t ProgramStatus) AsProgramStatus1() (ProgramStatus1, error) {
	var body ProgramStatus1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus1 overwrites any union data inside the ProgramStatus as the provided ProgramStatus1
func (t *ProgramStatus) FromProgramStatus1(v ProgramStatus1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus1 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus1
func (t *ProgramStatus) MergeProgramStatus1(v ProgramStatus1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsProgramStatus2 returns the union data inside the ProgramStatus as a ProgramStatus2
func (t ProgramStatus) AsProgramStatus2() (ProgramStatus2, error) {
	var body ProgramStatus2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus2 overwrites any union data inside the ProgramStatus as the provided ProgramStatus2
func (t *ProgramStatus) FromProgramStatus2(v ProgramStatus2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus2 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus2
func (t *ProgramStatus) MergeProgramStatus2(v ProgramStatus2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsProgramStatus3 returns the union data inside the ProgramStatus as a ProgramStatus3
func (t ProgramStatus) AsProgramStatus3() (ProgramStatus3, error) {
	var body ProgramStatus3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus3 overwrites any union data inside the ProgramStatus as the provided ProgramStatus3
func (t *ProgramStatus) FromProgramStatus3(v ProgramStatus3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus3 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus3
func (t *ProgramStatus) MergeProgramStatus3(v ProgramStatus3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsProgramStatus4 returns the union data inside the ProgramStatus as a ProgramStatus4
func (t ProgramStatus) AsProgramStatus4() (ProgramStatus4, error) {
	var body ProgramStatus4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus4 overwrites any union data inside the ProgramStatus as the provided ProgramStatus4
func (t *ProgramStatus) FromProgramStatus4(v ProgramStatus4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus4 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus4
func (t *ProgramStatus) MergeProgramStatus4(v ProgramStatus4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsProgramStatus5 returns the union data inside the ProgramStatus as a ProgramStatus5
func (t ProgramStatus) AsProgramStatus5() (ProgramStatus5, error) {
	var body ProgramStatus5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus5 overwrites any union data inside the ProgramStatus as the provided ProgramStatus5
func (t *ProgramStatus) FromProgramStatus5(v ProgramStatus5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus5 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus5
func (t *ProgramStatus) MergeProgramStatus5(v ProgramStatus5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsProgramStatus6 returns the union data inside the ProgramStatus as a ProgramStatus6
func (t ProgramStatus) AsProgramStatus6() (ProgramStatus6, error) {
	var body ProgramStatus6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus6 overwrites any union data inside the ProgramStatus as the provided ProgramStatus6
func (t *ProgramStatus) FromProgramStatus6(v ProgramStatus6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus6 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus6
func (t *ProgramStatus) MergeProgramStatus6(v ProgramStatus6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsProgramStatus7 returns the union data inside the ProgramStatus as a ProgramStatus7
func (t ProgramStatus) AsProgramStatus7() (ProgramStatus7, error) {
	var body ProgramStatus7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProgramStatus7 overwrites any union data inside the ProgramStatus as the provided ProgramStatus7
func (t *ProgramStatus) FromProgramStatus7(v ProgramStatus7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProgramStatus7 performs a merge with any union data inside the ProgramStatus, using the provided ProgramStatus7
func (t *ProgramStatus) MergeProgramStatus7(v ProgramStatus7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ProgramStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProgramStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAuthenticationConfig request
	GetAuthenticationConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConnectors request
	ListConnectors(ctx context.Context, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewConnector request with any body
	NewConnectorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewConnector(ctx context.Context, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConnector request
	DeleteConnector(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnector request
	GetConnector(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConnector request with any body
	UpdateConnectorWithBody(ctx context.Context, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConnector(ctx context.Context, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPipelines request
	ListPipelines(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewPipeline request with any body
	NewPipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewPipeline(ctx context.Context, body NewPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineDelete request
	PipelineDelete(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipeline request
	GetPipeline(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePipeline request with any body
	UpdatePipelineWithBody(ctx context.Context, pipelineId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePipeline(ctx context.Context, pipelineId openapi_types.UUID, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineConfig request
	GetPipelineConfig(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineDeployed request
	PipelineDeployed(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HttpOutput request with any body
	HttpOutputWithBody(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HttpOutput(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, body HttpOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HttpInput request with any body
	HttpInputWithBody(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineStats request
	PipelineStats(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineValidate request
	PipelineValidate(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PipelineAction request
	PipelineAction(ctx context.Context, pipelineId openapi_types.UUID, action string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrograms request
	GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewProgram request with any body
	NewProgramWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewProgram(ctx context.Context, body NewProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgram request
	DeleteProgram(ctx context.Context, programId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, programId openapi_types.UUID, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProgram request with any body
	UpdateProgramWithBody(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProgram(ctx context.Context, programId openapi_types.UUID, body UpdateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompileProgram request with any body
	CompileProgramWithBody(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompileProgram(ctx context.Context, programId openapi_types.UUID, body CompileProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAuthenticationConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthenticationConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConnectors(ctx context.Context, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConnectorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewConnectorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewConnectorRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewConnector(ctx context.Context, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewConnectorRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConnector(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConnectorRequest(c.Server, connectorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnector(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorRequest(c.Server, connectorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnectorWithBody(ctx context.Context, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorRequestWithBody(c.Server, connectorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnector(ctx context.Context, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorRequest(c.Server, connectorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPipelines(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPipelinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewPipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewPipelineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewPipeline(ctx context.Context, body NewPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewPipelineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineDelete(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineDeleteRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipeline(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipelineWithBody(ctx context.Context, pipelineId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineRequestWithBody(c.Server, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipeline(ctx context.Context, pipelineId openapi_types.UUID, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineRequest(c.Server, pipelineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineConfig(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineConfigRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineDeployed(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineDeployedRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HttpOutputWithBody(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHttpOutputRequestWithBody(c.Server, pipelineId, tableName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HttpOutput(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, body HttpOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHttpOutputRequest(c.Server, pipelineId, tableName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HttpInputWithBody(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHttpInputRequestWithBody(c.Server, pipelineId, tableName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineStats(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineStatsRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineValidate(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineValidateRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PipelineAction(ctx context.Context, pipelineId openapi_types.UUID, action string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPipelineActionRequest(c.Server, pipelineId, action)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewProgramWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewProgramRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewProgram(ctx context.Context, body NewProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewProgramRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgram(ctx context.Context, programId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramRequest(c.Server, programId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, programId openapi_types.UUID, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, programId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramWithBody(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramRequestWithBody(c.Server, programId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgram(ctx context.Context, programId openapi_types.UUID, body UpdateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramRequest(c.Server, programId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompileProgramWithBody(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompileProgramRequestWithBody(c.Server, programId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompileProgram(ctx context.Context, programId openapi_types.UUID, body CompileProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompileProgramRequest(c.Server, programId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAuthenticationConfigRequest generates requests for GetAuthenticationConfig
func NewGetAuthenticationConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/../config/authentication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConnectorsRequest generates requests for ListConnectors
func NewListConnectorsRequest(server string, params *ListConnectorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewConnectorRequest calls the generic NewConnector builder with application/json body
func NewNewConnectorRequest(server string, body NewConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewConnectorRequestWithBody(server, "application/json", bodyReader)
}

// NewNewConnectorRequestWithBody generates requests for NewConnector with any type of body
func NewNewConnectorRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConnectorRequest generates requests for DeleteConnector
func NewDeleteConnectorRequest(server string, connectorId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connector_id", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectorRequest generates requests for GetConnector
func NewGetConnectorRequest(server string, connectorId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connector_id", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConnectorRequest calls the generic UpdateConnector builder with application/json body
func NewUpdateConnectorRequest(server string, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConnectorRequestWithBody(server, connectorId, "application/json", bodyReader)
}

// NewUpdateConnectorRequestWithBody generates requests for UpdateConnector with any type of body
func NewUpdateConnectorRequestWithBody(server string, connectorId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connector_id", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPipelinesRequest generates requests for ListPipelines
func NewListPipelinesRequest(server string, params *ListPipelinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewPipelineRequest calls the generic NewPipeline builder with application/json body
func NewNewPipelineRequest(server string, body NewPipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewPipelineRequestWithBody(server, "application/json", bodyReader)
}

// NewNewPipelineRequestWithBody generates requests for NewPipeline with any type of body
func NewNewPipelineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPipelineDeleteRequest generates requests for PipelineDelete
func NewPipelineDeleteRequest(server string, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineRequest generates requests for GetPipeline
func NewGetPipelineRequest(server string, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePipelineRequest calls the generic UpdatePipeline builder with application/json body
func NewUpdatePipelineRequest(server string, pipelineId openapi_types.UUID, body UpdatePipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePipelineRequestWithBody(server, pipelineId, "application/json", bodyReader)
}

// NewUpdatePipelineRequestWithBody generates requests for UpdatePipeline with any type of body
func NewUpdatePipelineRequestWithBody(server string, pipelineId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPipelineConfigRequest generates requests for GetPipelineConfig
func NewGetPipelineConfigRequest(server string, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPipelineDeployedRequest generates requests for PipelineDeployed
func NewPipelineDeployedRequest(server string, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/deployed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHttpOutputRequest calls the generic HttpOutput builder with application/json body
func NewHttpOutputRequest(server string, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, body HttpOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHttpOutputRequestWithBody(server, pipelineId, tableName, params, "application/json", bodyReader)
}

// NewHttpOutputRequestWithBody generates requests for HttpOutput with any type of body
func NewHttpOutputRequestWithBody(server string, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/egress/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, params.Format); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Quantiles != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quantiles", runtime.ParamLocationQuery, *params.Quantiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Array != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "array", runtime.ParamLocationQuery, *params.Array); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHttpInputRequestWithBody generates requests for HttpInput with any type of body
func NewHttpInputRequestWithBody(server string, pipelineId openapi_types.UUID, tableName string, params *HttpInputParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/ingress/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, params.Force); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, params.Format); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Array != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "array", runtime.ParamLocationQuery, *params.Array); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdateFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "update_format", runtime.ParamLocationQuery, *params.UpdateFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPipelineStatsRequest generates requests for PipelineStats
func NewPipelineStatsRequest(server string, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPipelineValidateRequest generates requests for PipelineValidate
func NewPipelineValidateRequest(server string, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/validate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPipelineActionRequest generates requests for PipelineAction
func NewPipelineActionRequest(server string, pipelineId openapi_types.UUID, action string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action", runtime.ParamLocationPath, action)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramsRequest generates requests for GetPrograms
func NewGetProgramsRequest(server string, params *GetProgramsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.WithCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_code", runtime.ParamLocationQuery, *params.WithCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewProgramRequest calls the generic NewProgram builder with application/json body
func NewNewProgramRequest(server string, body NewProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewProgramRequestWithBody(server, "application/json", bodyReader)
}

// NewNewProgramRequestWithBody generates requests for NewProgram with any type of body
func NewNewProgramRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramRequest generates requests for DeleteProgram
func NewDeleteProgramRequest(server string, programId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "program_id", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, programId openapi_types.UUID, params *GetProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "program_id", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.WithCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "with_code", runtime.ParamLocationQuery, *params.WithCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProgramRequest calls the generic UpdateProgram builder with application/json body
func NewUpdateProgramRequest(server string, programId openapi_types.UUID, body UpdateProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProgramRequestWithBody(server, programId, "application/json", bodyReader)
}

// NewUpdateProgramRequestWithBody generates requests for UpdateProgram with any type of body
func NewUpdateProgramRequestWithBody(server string, programId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "program_id", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompileProgramRequest calls the generic CompileProgram builder with application/json body
func NewCompileProgramRequest(server string, programId openapi_types.UUID, body CompileProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompileProgramRequestWithBody(server, programId, "application/json", bodyReader)
}

// NewCompileProgramRequestWithBody generates requests for CompileProgram with any type of body
func NewCompileProgramRequestWithBody(server string, programId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "program_id", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/programs/%s/compile", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAuthenticationConfig request
	GetAuthenticationConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthenticationConfigResponse, error)

	// ListConnectors request
	ListConnectorsWithResponse(ctx context.Context, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error)

	// NewConnector request with any body
	NewConnectorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error)

	NewConnectorWithResponse(ctx context.Context, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error)

	// DeleteConnector request
	DeleteConnectorWithResponse(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteConnectorResponse, error)

	// GetConnector request
	GetConnectorWithResponse(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error)

	// UpdateConnector request with any body
	UpdateConnectorWithBodyWithResponse(ctx context.Context, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error)

	UpdateConnectorWithResponse(ctx context.Context, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error)

	// ListPipelines request
	ListPipelinesWithResponse(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*ListPipelinesResponse, error)

	// NewPipeline request with any body
	NewPipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewPipelineResponse, error)

	NewPipelineWithResponse(ctx context.Context, body NewPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*NewPipelineResponse, error)

	// PipelineDelete request
	PipelineDeleteWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineDeleteResponse, error)

	// GetPipeline request
	GetPipelineWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error)

	// UpdatePipeline request with any body
	UpdatePipelineWithBodyWithResponse(ctx context.Context, pipelineId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error)

	UpdatePipelineWithResponse(ctx context.Context, pipelineId openapi_types.UUID, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error)

	// GetPipelineConfig request
	GetPipelineConfigWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPipelineConfigResponse, error)

	// PipelineDeployed request
	PipelineDeployedWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineDeployedResponse, error)

	// HttpOutput request with any body
	HttpOutputWithBodyWithResponse(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HttpOutputResponse, error)

	HttpOutputWithResponse(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, body HttpOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*HttpOutputResponse, error)

	// HttpInput request with any body
	HttpInputWithBodyWithResponse(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HttpInputResponse, error)

	// PipelineStats request
	PipelineStatsWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineStatsResponse, error)

	// PipelineValidate request
	PipelineValidateWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineValidateResponse, error)

	// PipelineAction request
	PipelineActionWithResponse(ctx context.Context, pipelineId openapi_types.UUID, action string, reqEditors ...RequestEditorFn) (*PipelineActionResponse, error)

	// GetPrograms request
	GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error)

	// NewProgram request with any body
	NewProgramWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewProgramResponse, error)

	NewProgramWithResponse(ctx context.Context, body NewProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*NewProgramResponse, error)

	// DeleteProgram request
	DeleteProgramWithResponse(ctx context.Context, programId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error)

	// GetProgram request
	GetProgramWithResponse(ctx context.Context, programId openapi_types.UUID, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error)

	// UpdateProgram request with any body
	UpdateProgramWithBodyWithResponse(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramResponse, error)

	UpdateProgramWithResponse(ctx context.Context, programId openapi_types.UUID, body UpdateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramResponse, error)

	// CompileProgram request with any body
	CompileProgramWithBodyWithResponse(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileProgramResponse, error)

	CompileProgramWithResponse(ctx context.Context, programId openapi_types.UUID, body CompileProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CompileProgramResponse, error)
}

type GetAuthenticationConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthProvider
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAuthenticationConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthenticationConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConnectorDescr
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NewConnectorResp
}

// Status returns HTTPResponse.Status
func (r NewConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectorDescr
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateConnectorResp
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Pipeline
}

// Status returns HTTPResponse.Status
func (r ListPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NewPipelineResp
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r NewPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PipelineDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pipeline
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePipelineResp
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PipelineConfig
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPipelineConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineDeployedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PipelineRevision
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PipelineDeployedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineDeployedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HttpOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Chunk
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON410      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r HttpOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HttpOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HttpInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r HttpInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HttpInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PipelineStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PipelineValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PipelineActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PipelineActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PipelineActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProgramDescr
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetProgramsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NewProgramResp
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r NewProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramDescr
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateProgramResp
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompileProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CompileProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompileProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAuthenticationConfigWithResponse request returning *GetAuthenticationConfigResponse
func (c *ClientWithResponses) GetAuthenticationConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthenticationConfigResponse, error) {
	rsp, err := c.GetAuthenticationConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthenticationConfigResponse(rsp)
}

// ListConnectorsWithResponse request returning *ListConnectorsResponse
func (c *ClientWithResponses) ListConnectorsWithResponse(ctx context.Context, params *ListConnectorsParams, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error) {
	rsp, err := c.ListConnectors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConnectorsResponse(rsp)
}

// NewConnectorWithBodyWithResponse request with arbitrary body returning *NewConnectorResponse
func (c *ClientWithResponses) NewConnectorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error) {
	rsp, err := c.NewConnectorWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewConnectorResponse(rsp)
}

func (c *ClientWithResponses) NewConnectorWithResponse(ctx context.Context, body NewConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*NewConnectorResponse, error) {
	rsp, err := c.NewConnector(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewConnectorResponse(rsp)
}

// DeleteConnectorWithResponse request returning *DeleteConnectorResponse
func (c *ClientWithResponses) DeleteConnectorWithResponse(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteConnectorResponse, error) {
	rsp, err := c.DeleteConnector(ctx, connectorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConnectorResponse(rsp)
}

// GetConnectorWithResponse request returning *GetConnectorResponse
func (c *ClientWithResponses) GetConnectorWithResponse(ctx context.Context, connectorId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error) {
	rsp, err := c.GetConnector(ctx, connectorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorResponse(rsp)
}

// UpdateConnectorWithBodyWithResponse request with arbitrary body returning *UpdateConnectorResponse
func (c *ClientWithResponses) UpdateConnectorWithBodyWithResponse(ctx context.Context, connectorId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error) {
	rsp, err := c.UpdateConnectorWithBody(ctx, connectorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorResponse(rsp)
}

func (c *ClientWithResponses) UpdateConnectorWithResponse(ctx context.Context, connectorId openapi_types.UUID, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error) {
	rsp, err := c.UpdateConnector(ctx, connectorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorResponse(rsp)
}

// ListPipelinesWithResponse request returning *ListPipelinesResponse
func (c *ClientWithResponses) ListPipelinesWithResponse(ctx context.Context, params *ListPipelinesParams, reqEditors ...RequestEditorFn) (*ListPipelinesResponse, error) {
	rsp, err := c.ListPipelines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPipelinesResponse(rsp)
}

// NewPipelineWithBodyWithResponse request with arbitrary body returning *NewPipelineResponse
func (c *ClientWithResponses) NewPipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewPipelineResponse, error) {
	rsp, err := c.NewPipelineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewPipelineResponse(rsp)
}

func (c *ClientWithResponses) NewPipelineWithResponse(ctx context.Context, body NewPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*NewPipelineResponse, error) {
	rsp, err := c.NewPipeline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewPipelineResponse(rsp)
}

// PipelineDeleteWithResponse request returning *PipelineDeleteResponse
func (c *ClientWithResponses) PipelineDeleteWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineDeleteResponse, error) {
	rsp, err := c.PipelineDelete(ctx, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineDeleteResponse(rsp)
}

// GetPipelineWithResponse request returning *GetPipelineResponse
func (c *ClientWithResponses) GetPipelineWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error) {
	rsp, err := c.GetPipeline(ctx, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineResponse(rsp)
}

// UpdatePipelineWithBodyWithResponse request with arbitrary body returning *UpdatePipelineResponse
func (c *ClientWithResponses) UpdatePipelineWithBodyWithResponse(ctx context.Context, pipelineId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error) {
	rsp, err := c.UpdatePipelineWithBody(ctx, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineResponse(rsp)
}

func (c *ClientWithResponses) UpdatePipelineWithResponse(ctx context.Context, pipelineId openapi_types.UUID, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error) {
	rsp, err := c.UpdatePipeline(ctx, pipelineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineResponse(rsp)
}

// GetPipelineConfigWithResponse request returning *GetPipelineConfigResponse
func (c *ClientWithResponses) GetPipelineConfigWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPipelineConfigResponse, error) {
	rsp, err := c.GetPipelineConfig(ctx, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineConfigResponse(rsp)
}

// PipelineDeployedWithResponse request returning *PipelineDeployedResponse
func (c *ClientWithResponses) PipelineDeployedWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineDeployedResponse, error) {
	rsp, err := c.PipelineDeployed(ctx, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineDeployedResponse(rsp)
}

// HttpOutputWithBodyWithResponse request with arbitrary body returning *HttpOutputResponse
func (c *ClientWithResponses) HttpOutputWithBodyWithResponse(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HttpOutputResponse, error) {
	rsp, err := c.HttpOutputWithBody(ctx, pipelineId, tableName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHttpOutputResponse(rsp)
}

func (c *ClientWithResponses) HttpOutputWithResponse(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpOutputParams, body HttpOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*HttpOutputResponse, error) {
	rsp, err := c.HttpOutput(ctx, pipelineId, tableName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHttpOutputResponse(rsp)
}

// HttpInputWithBodyWithResponse request with arbitrary body returning *HttpInputResponse
func (c *ClientWithResponses) HttpInputWithBodyWithResponse(ctx context.Context, pipelineId openapi_types.UUID, tableName string, params *HttpInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HttpInputResponse, error) {
	rsp, err := c.HttpInputWithBody(ctx, pipelineId, tableName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHttpInputResponse(rsp)
}

// PipelineStatsWithResponse request returning *PipelineStatsResponse
func (c *ClientWithResponses) PipelineStatsWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineStatsResponse, error) {
	rsp, err := c.PipelineStats(ctx, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineStatsResponse(rsp)
}

// PipelineValidateWithResponse request returning *PipelineValidateResponse
func (c *ClientWithResponses) PipelineValidateWithResponse(ctx context.Context, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PipelineValidateResponse, error) {
	rsp, err := c.PipelineValidate(ctx, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineValidateResponse(rsp)
}

// PipelineActionWithResponse request returning *PipelineActionResponse
func (c *ClientWithResponses) PipelineActionWithResponse(ctx context.Context, pipelineId openapi_types.UUID, action string, reqEditors ...RequestEditorFn) (*PipelineActionResponse, error) {
	rsp, err := c.PipelineAction(ctx, pipelineId, action, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePipelineActionResponse(rsp)
}

// GetProgramsWithResponse request returning *GetProgramsResponse
func (c *ClientWithResponses) GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error) {
	rsp, err := c.GetPrograms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramsResponse(rsp)
}

// NewProgramWithBodyWithResponse request with arbitrary body returning *NewProgramResponse
func (c *ClientWithResponses) NewProgramWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewProgramResponse, error) {
	rsp, err := c.NewProgramWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewProgramResponse(rsp)
}

func (c *ClientWithResponses) NewProgramWithResponse(ctx context.Context, body NewProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*NewProgramResponse, error) {
	rsp, err := c.NewProgram(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewProgramResponse(rsp)
}

// DeleteProgramWithResponse request returning *DeleteProgramResponse
func (c *ClientWithResponses) DeleteProgramWithResponse(ctx context.Context, programId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error) {
	rsp, err := c.DeleteProgram(ctx, programId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramResponse(rsp)
}

// GetProgramWithResponse request returning *GetProgramResponse
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, programId openapi_types.UUID, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error) {
	rsp, err := c.GetProgram(ctx, programId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResponse(rsp)
}

// UpdateProgramWithBodyWithResponse request with arbitrary body returning *UpdateProgramResponse
func (c *ClientWithResponses) UpdateProgramWithBodyWithResponse(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramResponse, error) {
	rsp, err := c.UpdateProgramWithBody(ctx, programId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramResponse(rsp)
}

func (c *ClientWithResponses) UpdateProgramWithResponse(ctx context.Context, programId openapi_types.UUID, body UpdateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramResponse, error) {
	rsp, err := c.UpdateProgram(ctx, programId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramResponse(rsp)
}

// CompileProgramWithBodyWithResponse request with arbitrary body returning *CompileProgramResponse
func (c *ClientWithResponses) CompileProgramWithBodyWithResponse(ctx context.Context, programId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompileProgramResponse, error) {
	rsp, err := c.CompileProgramWithBody(ctx, programId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompileProgramResponse(rsp)
}

func (c *ClientWithResponses) CompileProgramWithResponse(ctx context.Context, programId openapi_types.UUID, body CompileProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CompileProgramResponse, error) {
	rsp, err := c.CompileProgram(ctx, programId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompileProgramResponse(rsp)
}

// ParseGetAuthenticationConfigResponse parses an HTTP response from a GetAuthenticationConfigWithResponse call
func ParseGetAuthenticationConfigResponse(rsp *http.Response) (*GetAuthenticationConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthenticationConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListConnectorsResponse parses an HTTP response from a ListConnectorsWithResponse call
func ParseListConnectorsResponse(rsp *http.Response) (*ListConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConnectorDescr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseNewConnectorResponse parses an HTTP response from a NewConnectorWithResponse call
func ParseNewConnectorResponse(rsp *http.Response) (*NewConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NewConnectorResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteConnectorResponse parses an HTTP response from a DeleteConnectorWithResponse call
func ParseDeleteConnectorResponse(rsp *http.Response) (*DeleteConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetConnectorResponse parses an HTTP response from a GetConnectorWithResponse call
func ParseGetConnectorResponse(rsp *http.Response) (*GetConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectorDescr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateConnectorResponse parses an HTTP response from a UpdateConnectorWithResponse call
func ParseUpdateConnectorResponse(rsp *http.Response) (*UpdateConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateConnectorResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPipelinesResponse parses an HTTP response from a ListPipelinesWithResponse call
func ParseListPipelinesResponse(rsp *http.Response) (*ListPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Pipeline
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewPipelineResponse parses an HTTP response from a NewPipelineWithResponse call
func ParseNewPipelineResponse(rsp *http.Response) (*NewPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NewPipelineResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePipelineDeleteResponse parses an HTTP response from a PipelineDeleteWithResponse call
func ParsePipelineDeleteResponse(rsp *http.Response) (*PipelineDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPipelineResponse parses an HTTP response from a GetPipelineWithResponse call
func ParseGetPipelineResponse(rsp *http.Response) (*GetPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pipeline
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePipelineResponse parses an HTTP response from a UpdatePipelineWithResponse call
func ParseUpdatePipelineResponse(rsp *http.Response) (*UpdatePipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePipelineResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPipelineConfigResponse parses an HTTP response from a GetPipelineConfigWithResponse call
func ParseGetPipelineConfigResponse(rsp *http.Response) (*GetPipelineConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PipelineConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePipelineDeployedResponse parses an HTTP response from a PipelineDeployedWithResponse call
func ParsePipelineDeployedResponse(rsp *http.Response) (*PipelineDeployedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineDeployedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PipelineRevision
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseHttpOutputResponse parses an HTTP response from a HttpOutputWithResponse call
func ParseHttpOutputResponse(rsp *http.Response) (*HttpOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HttpOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Chunk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHttpInputResponse parses an HTTP response from a HttpInputWithResponse call
func ParseHttpInputResponse(rsp *http.Response) (*HttpInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HttpInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePipelineStatsResponse parses an HTTP response from a PipelineStatsWithResponse call
func ParsePipelineStatsResponse(rsp *http.Response) (*PipelineStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePipelineValidateResponse parses an HTTP response from a PipelineValidateWithResponse call
func ParsePipelineValidateResponse(rsp *http.Response) (*PipelineValidateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePipelineActionResponse parses an HTTP response from a PipelineActionWithResponse call
func ParsePipelineActionResponse(rsp *http.Response) (*PipelineActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PipelineActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProgramsResponse parses an HTTP response from a GetProgramsWithResponse call
func ParseGetProgramsResponse(rsp *http.Response) (*GetProgramsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProgramDescr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseNewProgramResponse parses an HTTP response from a NewProgramWithResponse call
func ParseNewProgramResponse(rsp *http.Response) (*NewProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NewProgramResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteProgramResponse parses an HTTP response from a DeleteProgramWithResponse call
func ParseDeleteProgramResponse(rsp *http.Response) (*DeleteProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProgramResponse parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResponse(rsp *http.Response) (*GetProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramDescr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateProgramResponse parses an HTTP response from a UpdateProgramWithResponse call
func ParseUpdateProgramResponse(rsp *http.Response) (*UpdateProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateProgramResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCompileProgramResponse parses an HTTP response from a CompileProgramWithResponse call
func ParseCompileProgramResponse(rsp *http.Response) (*CompileProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompileProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get authentication provider configuration
	// (GET /../config/authentication)
	GetAuthenticationConfig(ctx echo.Context) error
	// Fetch connectors, optionally filtered by name or ID
	// (GET /connectors)
	ListConnectors(ctx echo.Context, params ListConnectorsParams) error
	// Create a new connector.
	// (POST /connectors)
	NewConnector(ctx echo.Context) error
	// Delete an existing connector.
	// (DELETE /connectors/{connector_id})
	DeleteConnector(ctx echo.Context, connectorId openapi_types.UUID) error
	// Fetch a connector by ID.
	// (GET /connectors/{connector_id})
	GetConnector(ctx echo.Context, connectorId openapi_types.UUID) error
	// Change a connector's name, description or configuration.
	// (PATCH /connectors/{connector_id})
	UpdateConnector(ctx echo.Context, connectorId openapi_types.UUID) error
	// Fetch pipelines, optionally filtered by name or ID.
	// (GET /pipelines)
	ListPipelines(ctx echo.Context, params ListPipelinesParams) error
	// Create a new pipeline.
	// (POST /pipelines)
	NewPipeline(ctx echo.Context) error
	// Delete a pipeline. The pipeline must be in the shutdown state.
	// (DELETE /pipelines/{pipeline_id})
	PipelineDelete(ctx echo.Context, pipelineId openapi_types.UUID) error
	// Fetch a pipeline by ID.
	// (GET /pipelines/{pipeline_id})
	GetPipeline(ctx echo.Context, pipelineId openapi_types.UUID) error
	// Change a pipeline's name, description, code, configuration, or connectors.
	// (PATCH /pipelines/{pipeline_id})
	UpdatePipeline(ctx echo.Context, pipelineId openapi_types.UUID) error
	// Fetch a pipeline's configuration.
	// (GET /pipelines/{pipeline_id}/config)
	GetPipelineConfig(ctx echo.Context, pipelineId openapi_types.UUID) error
	// Return the currently deployed version of the pipeline, if any.
	// (GET /pipelines/{pipeline_id}/deployed)
	PipelineDeployed(ctx echo.Context, pipelineId openapi_types.UUID) error
	// Subscribe to a stream of updates from a SQL view or table.
	// (POST /pipelines/{pipeline_id}/egress/{table_name})
	HttpOutput(ctx echo.Context, pipelineId openapi_types.UUID, tableName string, params HttpOutputParams) error
	// Push data to a SQL table.
	// (POST /pipelines/{pipeline_id}/ingress/{table_name})
	HttpInput(ctx echo.Context, pipelineId openapi_types.UUID, tableName string, params HttpInputParams) error
	// Retrieve pipeline metrics and performance counters.
	// (GET /pipelines/{pipeline_id}/stats)
	PipelineStats(ctx echo.Context, pipelineId openapi_types.UUID) error
	// Validate a pipeline.
	// (GET /pipelines/{pipeline_id}/validate)
	PipelineValidate(ctx echo.Context, pipelineId openapi_types.UUID) error
	// Change the desired state of the pipeline.
	// (POST /pipelines/{pipeline_id}/{action})
	PipelineAction(ctx echo.Context, pipelineId openapi_types.UUID, action string) error
	// Fetch programs, optionally filtered by name or ID.
	// (GET /programs)
	GetPrograms(ctx echo.Context, params GetProgramsParams) error
	// Create a new program.
	// (POST /programs)
	NewProgram(ctx echo.Context) error
	// Delete a program.
	// (DELETE /programs/{program_id})
	DeleteProgram(ctx echo.Context, programId openapi_types.UUID) error
	// Fetch a program by ID.
	// (GET /programs/{program_id})
	GetProgram(ctx echo.Context, programId openapi_types.UUID, params GetProgramParams) error
	// Change one or more of a program's code, description or name.
	// (PATCH /programs/{program_id})
	UpdateProgram(ctx echo.Context, programId openapi_types.UUID) error
	// Mark a program for compilation.
	// (POST /programs/{program_id}/compile)
	CompileProgram(ctx echo.Context, programId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAuthenticationConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthenticationConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAuthenticationConfig(ctx)
	return err
}

// ListConnectors converts echo context to params.
func (w *ServerInterfaceWrapper) ListConnectors(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConnectorsParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListConnectors(ctx, params)
	return err
}

// NewConnector converts echo context to params.
func (w *ServerInterfaceWrapper) NewConnector(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewConnector(ctx)
	return err
}

// DeleteConnector converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteConnector(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connector_id" -------------
	var connectorId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "connector_id", runtime.ParamLocationPath, ctx.Param("connector_id"), &connectorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connector_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteConnector(ctx, connectorId)
	return err
}

// GetConnector converts echo context to params.
func (w *ServerInterfaceWrapper) GetConnector(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connector_id" -------------
	var connectorId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "connector_id", runtime.ParamLocationPath, ctx.Param("connector_id"), &connectorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connector_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConnector(ctx, connectorId)
	return err
}

// UpdateConnector converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateConnector(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connector_id" -------------
	var connectorId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "connector_id", runtime.ParamLocationPath, ctx.Param("connector_id"), &connectorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connector_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateConnector(ctx, connectorId)
	return err
}

// ListPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) ListPipelines(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPipelinesParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPipelines(ctx, params)
	return err
}

// NewPipeline converts echo context to params.
func (w *ServerInterfaceWrapper) NewPipeline(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewPipeline(ctx)
	return err
}

// PipelineDelete converts echo context to params.
func (w *ServerInterfaceWrapper) PipelineDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PipelineDelete(ctx, pipelineId)
	return err
}

// GetPipeline converts echo context to params.
func (w *ServerInterfaceWrapper) GetPipeline(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPipeline(ctx, pipelineId)
	return err
}

// UpdatePipeline converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePipeline(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdatePipeline(ctx, pipelineId)
	return err
}

// GetPipelineConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetPipelineConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPipelineConfig(ctx, pipelineId)
	return err
}

// PipelineDeployed converts echo context to params.
func (w *ServerInterfaceWrapper) PipelineDeployed(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PipelineDeployed(ctx, pipelineId)
	return err
}

// HttpOutput converts echo context to params.
func (w *ServerInterfaceWrapper) HttpOutput(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// ------------- Path parameter "table_name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table_name", runtime.ParamLocationPath, ctx.Param("table_name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HttpOutputParams
	// ------------- Required query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, true, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, false, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// ------------- Optional query parameter "quantiles" -------------

	err = runtime.BindQueryParameter("form", true, false, "quantiles", ctx.QueryParams(), &params.Quantiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quantiles: %s", err))
	}

	// ------------- Optional query parameter "array" -------------

	err = runtime.BindQueryParameter("form", true, false, "array", ctx.QueryParams(), &params.Array)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter array: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.HttpOutput(ctx, pipelineId, tableName, params)
	return err
}

// HttpInput converts echo context to params.
func (w *ServerInterfaceWrapper) HttpInput(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// ------------- Path parameter "table_name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table_name", runtime.ParamLocationPath, ctx.Param("table_name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table_name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HttpInputParams
	// ------------- Required query parameter "force" -------------

	err = runtime.BindQueryParameter("form", true, true, "force", ctx.QueryParams(), &params.Force)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter force: %s", err))
	}

	// ------------- Required query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, true, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "array" -------------

	err = runtime.BindQueryParameter("form", true, false, "array", ctx.QueryParams(), &params.Array)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter array: %s", err))
	}

	// ------------- Optional query parameter "update_format" -------------

	err = runtime.BindQueryParameter("form", true, false, "update_format", ctx.QueryParams(), &params.UpdateFormat)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter update_format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.HttpInput(ctx, pipelineId, tableName, params)
	return err
}

// PipelineStats converts echo context to params.
func (w *ServerInterfaceWrapper) PipelineStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PipelineStats(ctx, pipelineId)
	return err
}

// PipelineValidate converts echo context to params.
func (w *ServerInterfaceWrapper) PipelineValidate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PipelineValidate(ctx, pipelineId)
	return err
}

// PipelineAction converts echo context to params.
func (w *ServerInterfaceWrapper) PipelineAction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pipeline_id" -------------
	var pipelineId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, ctx.Param("pipeline_id"), &pipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipeline_id: %s", err))
	}

	// ------------- Path parameter "action" -------------
	var action string

	err = runtime.BindStyledParameterWithLocation("simple", false, "action", runtime.ParamLocationPath, ctx.Param("action"), &action)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PipelineAction(ctx, pipelineId, action)
	return err
}

// GetPrograms converts echo context to params.
func (w *ServerInterfaceWrapper) GetPrograms(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProgramsParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "with_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "with_code", ctx.QueryParams(), &params.WithCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter with_code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPrograms(ctx, params)
	return err
}

// NewProgram converts echo context to params.
func (w *ServerInterfaceWrapper) NewProgram(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewProgram(ctx)
	return err
}

// DeleteProgram converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProgram(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "program_id" -------------
	var programId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "program_id", runtime.ParamLocationPath, ctx.Param("program_id"), &programId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter program_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteProgram(ctx, programId)
	return err
}

// GetProgram converts echo context to params.
func (w *ServerInterfaceWrapper) GetProgram(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "program_id" -------------
	var programId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "program_id", runtime.ParamLocationPath, ctx.Param("program_id"), &programId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter program_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProgramParams
	// ------------- Optional query parameter "with_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "with_code", ctx.QueryParams(), &params.WithCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter with_code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProgram(ctx, programId, params)
	return err
}

// UpdateProgram converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProgram(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "program_id" -------------
	var programId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "program_id", runtime.ParamLocationPath, ctx.Param("program_id"), &programId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter program_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProgram(ctx, programId)
	return err
}

// CompileProgram converts echo context to params.
func (w *ServerInterfaceWrapper) CompileProgram(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "program_id" -------------
	var programId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "program_id", runtime.ParamLocationPath, ctx.Param("program_id"), &programId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter program_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CompileProgram(ctx, programId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/../config/authentication", wrapper.GetAuthenticationConfig)
	router.GET(baseURL+"/connectors", wrapper.ListConnectors)
	router.POST(baseURL+"/connectors", wrapper.NewConnector)
	router.DELETE(baseURL+"/connectors/:connector_id", wrapper.DeleteConnector)
	router.GET(baseURL+"/connectors/:connector_id", wrapper.GetConnector)
	router.PATCH(baseURL+"/connectors/:connector_id", wrapper.UpdateConnector)
	router.GET(baseURL+"/pipelines", wrapper.ListPipelines)
	router.POST(baseURL+"/pipelines", wrapper.NewPipeline)
	router.DELETE(baseURL+"/pipelines/:pipeline_id", wrapper.PipelineDelete)
	router.GET(baseURL+"/pipelines/:pipeline_id", wrapper.GetPipeline)
	router.PATCH(baseURL+"/pipelines/:pipeline_id", wrapper.UpdatePipeline)
	router.GET(baseURL+"/pipelines/:pipeline_id/config", wrapper.GetPipelineConfig)
	router.GET(baseURL+"/pipelines/:pipeline_id/deployed", wrapper.PipelineDeployed)
	router.POST(baseURL+"/pipelines/:pipeline_id/egress/:table_name", wrapper.HttpOutput)
	router.POST(baseURL+"/pipelines/:pipeline_id/ingress/:table_name", wrapper.HttpInput)
	router.GET(baseURL+"/pipelines/:pipeline_id/stats", wrapper.PipelineStats)
	router.GET(baseURL+"/pipelines/:pipeline_id/validate", wrapper.PipelineValidate)
	router.POST(baseURL+"/pipelines/:pipeline_id/:action", wrapper.PipelineAction)
	router.GET(baseURL+"/programs", wrapper.GetPrograms)
	router.POST(baseURL+"/programs", wrapper.NewProgram)
	router.DELETE(baseURL+"/programs/:program_id", wrapper.DeleteProgram)
	router.GET(baseURL+"/programs/:program_id", wrapper.GetProgram)
	router.PATCH(baseURL+"/programs/:program_id", wrapper.UpdateProgram)
	router.POST(baseURL+"/programs/:program_id/compile", wrapper.CompileProgram)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y93W4cObIg/CpEzgfINlIlyW13T2vw4UAt2z066x+NJXfjwGmoWJksFdtZZHWSKbnG",
	"MHAw2Mu52IvG7ALzCnt1sJf7NH6SBSNIJvOvKlWW3O4eDQZoq5I/wWAw/hgRfB+lcr6Qggmtov33kUpn",
	"bE7hnwda03TGskMpBEu1LMyPGVNpwReaSxHtR09kMaeaaElolhFqO5DU9VAkKwsuzgk1v035OSkXGdVs",
	"FMXRopALVmjOYDLf5Yxn5u//r2DTaD/6w04F3o6FbccDdJRFH+KIqzMuFqVug3ekiJ5xRagg0ILIwvxb",
	"lnpR6n+L4kgvFyzajyZS5owKM5igc9Ye6ICUgv9cMsIzJjSfclaQqSzs6LjsORN6VI2ptFm4GbJgOTXj",
	"nHWPfTpjRNNJzgx0F5xd4qgeIaSaIiNadkwBc/xc8oJl0f5rXEKAlriO3CZAb/x4cvITS7UB+aDUs+NC",
	"XvCMwa5LwV5Mo/3X7xu7dnCpDuW54Fqu2zM3WtCjCXfwqQOm5tTfS3mesyPYD70cOn2jVxOExuc2GG8+",
	"xNHhrBRvu2hEMU3k1JK4glNBTv7ytL67o0Qkwuz5WLGfSyZSdibK+YQVYzLlLM+I0rIwvWeMyOnUjmn+",
	"Ss28BDfvgpnh9YwlQmla+DZKF4zOCRUZSakgE0ZKBWRD+HyRA42aEThAlLGcX7BiOUKAFnSZS5oZegMY",
	"MsIFDDqecHGWUU3HMRlr9k67P2RBxj8paT8i/InI2IKJzJx6if3NV3NcDKsw4LRPv5ugjdXvqGJfPyBM",
	"pDJjGZlwQYulAzUmbHQ+is2v5rMZF6cxZxpaRnEkyjw3y432dVGyjvPpV9Ce/d9PXjx3k436x6oOTmNP",
	"zYgeIi701w+iOJpzweflPNrf9QNwodk5K8wIHr8dnIK9082lH578MFq/yAaZN6HsYgGHMi/n4hR+bpO6",
	"IesUWhDTkwTfgcCfUZ3OLBUf0jzlmhFAJmKji//bM2v+oHlu2c1qMeAh/PCmiYIP4Q9N+B9JCxrATtOU",
	"LTR5/urpU3JB85KpbtGwKFjKFYzQHPDYfXLn0PQGRPyBPH5HzdFTidgm4x8OXh7++eDl2PAKRfyI5oCO",
	"t/fGo7DRnfsPH97tbHn/4UPb9Luj74+en5pz+ejg9LH575OnLw7whxevvnsKP33/+MWzx6cv/2McE6bT",
	"UWPERGhJnkvBYMDTo2fQx/z35PTg2TEA0Jh/d1w7ao6we4gwIG6V0rxHBMKnfvQBcI8eHx49O3h6Zy++",
	"7xCD3QApmwKlO2n8qCnpLbXcwXPndzION+Hg5cuD/xgDlu+uldPwNQCw+xTOFzxnx4U8L+j8pTm3qkPR",
	"sR8MHn4uWckIJQvsAsCnMArI/PbJu2CFI+pVp+0H26y5Cte9G3qrdxyC8tfFSEA2eP1kS1k9sSwA2haw",
	"bntXw4pqqZ30QxzN6buzSTmdsoJlZwVLZZGpLlGTvl0UTKmyYETPCqZmMs8sO3vH5zQndC5LAcLWjkLc",
	"sGSyBBphIltILjSZsKmEcarfEsEVWVCQyLb5JJxzztIZFVzNR4Q8l9p0Nsq10Qa5IkJqQhMxo0VGJrIU",
	"2b4ZoWBO0FOi5jTPjVSnSzJh+pIx0ZokEX4WM6gu+Pk5wG9UhtoCPKyxU+IvZzydkbk0o8C+zWEigwvG",
	"L1jmVZuMTWmZwxB7ZM7z3BLeVUVhQYVayGLtfp+6hm7LmyfND+RhWEmujwxdtAnEf/fiThadloyl9UE2",
	"TEWln2AC1eB831ZxnOWxmiE1zARrR4Rjx251K9F3lLVx9wrtp8CqyWoUUZYwZwvyx+eGcJ/JDOBnwhDL",
	"6+jSqBdRHClBF2omw+0MuhaFLF4ytZBCdTF4gZMboVYwXRYCj+XLxyen5OD4yJ8EZfRYZgZrb3bGNOV5",
	"BzN5BB9Yhh3JnGlqjoxVtVMpNIORp3i+UfXnimRMs2LOLSxj6H1mlNtxYPhVOK++t0GA9RPzDUxIgphB",
	"pqIWLDXCzRrICCRI3SiOGIpc2LW3Ql6KI2NHIlPt2qM5U4qed0Dw53JOxXbBaAb2hkMFtO6cyJrp1lbY",
	"ejfPt9bbu276GjZivzVdpPrEoLtPr4W92FSLNSqpUyiGKq9Dz6c9kMEknWsLhV+bLgNbzBJBimfAGYoL",
	"WihGCnqJstkxdzIt5BwtTi8iDM1Ia5tha2UMTLRM/flZxSK73EnbDi4EpTDT4BxFXTvoPBHdThbrqDIf",
	"neWURKm6SCLzD2MB4r+sJWn+MErcMF9L1y7AkXlsMVBtxlDLpikcmt4PtPO7NWkDk1Ok8TxZr4DzI/Ai",
	"LbkOtItA5ifCsuiBziYLSIenJG5xRPPXhAXuuEoa1LW+D3H070qKV+BIeeJVvvp4J+XCiHSW4ZFERXJG",
	"xTkj7MKQIVK5gpP8mKYzwqwDhAtCodM2NtHg6ggQ5bljIqiw/hxD1VKAG8doQF4BNIO59YCjZ0TIj4wo",
	"hC4Ril2wguYk46AoCk0u6RKcQwUzSpn5RZXpzLmNgC9aMceFYoU+y1jOtDn5l4yfzzTLgLtN2F95OQch",
	"KC+nOX1rWhT0slMWPjc9J7KYSZn9pWTFsov5FZUVgS5SIzTcWRTBCIaSaMutBbQXtgJxNgVZxgUxcg0E",
	"HteKpExogxUkuztjKtKZLMZ3DcJRD0XXBKja8hLNVQZOJdNgKvNcXqI0YwQ7V2C3GQ6d6rYz5qv7azVQ",
	"HNl0XOv5QX3/ynM0jpMdJbYQd3GW5+zS84chBmFaMEO+lAh2WZ24a9RbG8rnOp25zrjbOmpff/N9sPN7",
	"sNJax6ZadKESNUj05wYsy+AVlUfA9TXeaazSy3sWccwXLOeCXZkiFrbjpgTxshSaz1mHGdOhFR+0b4jM",
	"vFyzuVo3Ufs66kOvd4cWBV0Ooc0pP9+cME3nHqoEXJ4XdG63fpjct24eQwJth+anE3pFI+vp3JHFADJ3",
	"TQdQuYMArdZP9DyF88Yr/VBm7cM9aLXj8ei7k2PnS+s6Il2GFzrHM6+EBd0ri+fw5eOD08fk9OC7p4+d",
	"k/MOqG4XtEhntLj7py6yWknQdpFNiq4mtfOQOtUMpHg3uiP59rB2oZsy6Yyt3b31hAs8zULaT7K1wznw",
	"SH46wVazrqbXF6DG/PrWg9UCvzzzwQK2wn5AFPaquj+bD0ResCAgwK4T7IUfGUnLwqjr+ZJkEpyvVqUn",
	"NCMzmcIQnKkRIUdCaUZRbU1zbjT6lIJBnQg9K5g5GGzbqcK2H9zJCqNea+wYuISaunVgEsCHKI5CRTuK",
	"o59LKjTPmerU/h3b7WBV2rA6mNKx05hwkeYl6NpKU83TOnZRRS9Q7EOLUnU5xpyHdKhMQKfrhzgyQ7Kh",
	"vaz6AetoUVcAhBu267i5sboOWh1d3+dyYqwWLxxDxBDFtObivAMb6aI8WxRyynPW4Vd+LGC3D49fEddo",
	"1HkDWd1jcHF+Bo7+s1KxtEPTcjcWeBvABZnztJCKpVJkQHuXlIOJTMZzLs4mVKezM8X/ytz9yJhomYhz",
	"pltXHIZSC5nnrIidpx9G3N3Axd89d8dyzCg0t3Y29CCmh79yqIDCJSuyKNXM0DB2cea69U05JmaoJydU",
	"JyJnVOl+ZLj+M3rByIQxUTnG7mipaZ4IahCsCM3zynV8F2IkevdtXNuWRMDoC6oUy4jiImWEaoKQScEa",
	"S5lRhZC4DRol4tEn7selLN6yLs39uTfHQSPCdnBLRjPVnGiI1bsuvgfWisZ7lnEDBc2Pay1WsYcu91tT",
	"e0IfXSW9NvUtOvZBrFqzNuAExc3Ga+vUDlqLw1bDV9dgnRb9AwTzcQ8ztD40zzZKxQpyOWPCmhTiPBF1",
	"E9TIQ01FykYhV+65jPPTrrqLc3FzZ3WjdHN7s2lfbmgjb3hfF29ua127OXpD5tvqa8e4c0dXyfQVd5EV",
	"2Q27iqzM54ueMKCDaszCNsKrN7s6lsWEz+claneN86KLMkWtGpRoTblAYcKDi0rBUqYULZbgQC5FoLdt",
	"6sBpaD9rPDhG1vrVbOLGaVyyd5ypRaCtXklxdObnMJPOdyuC/Vx5il27JiX7AQLYa1isQFvpounUadvm",
	"bqB5Vy4GvmDdNADOjI5DcGrGAHbs+gPdQjQpywh7x9LSMOna0cioZttm9q7zYQ2mMzQJhu7eCbZGpmgw",
	"unF/uP0dzt3q4QGdHC6XeDfaxt5T+8Vg0Eb5VEYBxuMUDF2dVDtjaZQIvHqk5PTwmIAx6a45CkLJq5dH",
	"na5ERMgZKISDN/KSKkKV4udw/aKVs2etxZaIgHIc+xiyzw3a9yhq7V+LIBoLiT1trjoLJ54YesS/NUDR",
	"DuAKg/T81ZqyUdGNowI9dUHTt5V+4n5PRFEKAY6BjMiJYsVF1ejg+MiZ+BecYnT0949PyY7rPa6uvSF+",
	"8Q9/IIZl5nzK0mWaN2xtZ71U91m01HJOtRQkpQtdukjwWv/athFyJDJ+wbPS2CCwUoXBXAUVCpRL5TpV",
	"g9PCKU4TsziWSwxMv0eOBHFKqTOWwpHUDMM0MLCbU8PVYhBTdmowYahIBJ8vcp5yTRJDV6mxaGalzuSl",
	"SKJgSDfJ+MR+HeNII0LMfiYiaFoLWGuTvN03rkiJFrWWJJXzeSl4SjVLxCXXs3oXe9tYsMmSAJQQKGMh",
	"sRg5wYXldMJyM68bZCbL4jynShG1nE9kTu58/Ps/7wJq790zhye7d89iBRbDElFtgNLGRjV4NA0thaI1",
	"ijZ2UQBrwjj6BbNaguFjOdPMnN8iaG+XvmCFOcNmEQ2ct6gfLhgJTUTomzLAyFKbcbgssxABNSqo4SKM",
	"lQIbSJE7452MLXK5HMdkvAMyZRwnYrwDEYX4o9tuxFi1r5Ml4eJCvjULr6PBTRI7Pjo+fnFySnYudv3x",
	"UzvvA73yg50a1jEeQ+5CIhyhffyf//3jL/8Z/P9/JOLjL38j7n8ff/lbIuw6Wr/jDx///k8zmpGTjwxh",
	"i4//+L9Vu3/8VyI+/v2fkHti9AOzhnr/YEDfimXB741Jw9F/+ZvHIUxzJLjmNOd/XTnNx1/+Xl90+P//",
	"0//Jf60jKYSoOeUxRrp2frP/+PiP/2p+xy1z33/5G5JMqz/OG0ISfn9ZCoft4NsvK5f3nx9/+d8rv/4v",
	"GB92IRFPILoPqMrx+Uco/4Cn0FSXNPeyFhzKZhnANW07PPNzmbHccKo5FfSctbl9oOEn4kigyx16xfUT",
	"PaOK6EtpJyVU64JPShAHSsmUG1kLJzYRXAdqCcQRk3v3LFyWaZUqtgG/gTC9RJ8/GvOJuJRlnpGcv21o",
	"QFqSTMY+pPjePasJNIdORENQB2jrknSnbW6fCCOgeYoeQC5KWap8SeZScMg/nEg9w4g+lIpKM1aohsDX",
	"8pKCc7C1O51ejFEiXoh8SdC37zOvQErwhkwKRO5EXjjlMBFwNKiqTVcqpvbJGM+NYZKWjMeIykpCYrCN",
	"Yr4XsFDFcrx4CTkoRLNWkawgvhNRl9/eiQouGgOhRR+KokBvbCtRVgsyvB2BqRSgin50WQi8twH9DgYx",
	"atrrsVPjxm+QuKn5wFNDAykTtOAyrpxHU14oDWkfiWhtlc8FCxYPeoWTRAFcVGQwgiALmedqpRoHRzNA",
	"R+NkN/GBItno22NUY+pK8Lg6ljZYTUH+TRJhrH0SES4yCMl0obqtMw4+X1WmKVNqWub50uyn5f0sg6y8",
	"JJoif4ricDwaxDG7CyVHVFEchYIqiqNQoJivAGAUR5YqozgKZV8UR8gTu2+gQpt77b11d3jSqqv2IW7X",
	"Ta7ON7gaJ3cyyZTY0qgKawlZmOByujsgUmTwZTT+eGVv3gl267R3B1rediBveF/ntXin969yDloIOy1G",
	"j5xeh5/dpaH+vhrCuvJ90WVnnXXacRzw7ilyB13od4F3X3B2qeC6zWdmAdc9hmBrF1pdRbJuA3+0zOXR",
	"o6fknAljA1SCCCkfssM6Tkt1ezLIKffSZoR3ueOC24pPHKv7iqGaYcWu9roB7JYGGW7BlXSVtt68+AHO",
	"hoJj39OFZ67WMYGxvhnI/5hMylD1mVE44kumvcsMYXBUEAb9WFb7XArWxR3boWXVYlxMbisMH+D4Uxv2",
	"RU5To5haEQ/pgCEQx5ibfVU45BQobjspd3e/YuRlqSCOGqZnqha1fOjwcPJzPnwaUFbMqG4K9ECCHR9M",
	"1DWP6XbV9YD8ZBkmo3tZiEK1e6z6ATv5OX/s/I1dIgkPZpVYFIreQcfo5OfcJn8Wz2yCy7oD5WEaUD7B",
	"4KxnAbALq1ew2idYjT0AkJOl0mzeh0v4uPPipA2G9f8USzhwEpU+Bv4eKvBKejWU4cTdhR46albsN8H/",
	"6fLtWVnwzsu6XJ5zcVYWed9XWeqezw1Y3SzhmLURelhnV82L1hLQn2nVj3Z1hN4F9sJYDdgFlpcPPelX",
	"9dAncqSBt1HUrcC2JjlXYESgXbdZqhb2HSzVMGOsQzxeKXXLTtqNlr5bRffF3hUM0l3qN877t3FMt3FM",
	"t3FMnyWOKeoQ3L0FVKyMRbnqSKBDgVAB04PG3tFU3RwF3I7waSK43lJWKgaXFuPtn9iYyKpSy3g85ucC",
	"cvpfk/eJSCLQZ59ywRBXSUT2yd6D2H/C1FX8+Sv4mYmsuz0TWbv1JS0EF+fw05TmimFTs6zT5YLB74nN",
	"Xl7QQpnFnfzlaRJBO5vt61qJVJZCw7FOkiQC3TF9/OIJKpHmJyA9w+T2HsSuZs3eV6MkSsQH8gYQ0OJz",
	"Hm7zx2pKq619QHO3zE5hG2RSd90CO9yvn6axh+s72E0JZvb8uhWyXR+6DlkTIXGAy2qWEA/VqrvEYrO0",
	"Q/v62zVYEeo2LPvYj1QlIHcP6TibESzj1Fjl+/sYbueH2N8X7PLMdR9jzLRrC3GHfU2vEHgIudy+tkUt",
	"uXlspO84JuO3dPoW6na95YIprsabpzRjOu6Vcg9t6qzR2d9xBR4S8G4MSkPcMNuhy7G10vX3PMyL3NAB",
	"WB9j41TFQWgflKRY1VoMs2B6Br9K8mDHlg6JQBu2mY1Aya6tvGp6oZFx2+RoSuhEMaHjCuygSuUlz3My",
	"YeQtWxhdyjl9qs4uUxuUohUDFAz9L5XAFewyEdU1kpHiv2LK4/Mw3HZzUl+EIc9fSvrjmwH0/Qln57NV",
	"zbIwr0lYxFbrU926703MJvo0RVffzI1lVP3nUjBjOpG3jC2Co45NEiz5EZyUT76AMRAFvzSBuiKBgrNg",
	"/RBXE31XyEJ0qPwVyeiHaug6pPZDlzvBGVctO+dDHHExle3BEvGj4XRPWJ6xgsbglVYuhRZqcvjQHCJL",
	"7fzIFj94J1+vAadG5CBsA7ZQwRVT7mbFX6iMyGHFgqeM2aHAG+jrcWCJjpC4rcVr0/4UTFDaqxUc10cT",
	"HhwfGZ4vL5VdWZAfLDIXs1FfZxX44FaJ6l8gLuBi163LNFXVHa+yhQ8h1FCKlC20wjise5YA741IA0Ug",
	"bagrUhx4yuwvR48SQcIqwoRrg+YKxTbevI3hg+rMEyIYQ9/DhDkTNXOV7rh2ka/ouceqH7XoFViE37J7",
	"ZvD63lvE1CvXwsbihtrtTYR3FCqC2Z+qnFcbCnckpoldw+MLViyrWeD2pgNdVXHnEaklgLrMz/9mlGlo",
	"+pJlCyoyOoLIHpor6RtlvGCp6cXFOVPalSxBGJ0GDHETfz49Pf5TIhTD8JlxXxAbF3D1McYokL5WDBtV",
	"5ZmUw7gTf0g3VdqDwUFhI6Vc6o2NOLJ0AYESShr8dKhW5CBMd7XHYl7mmkMyuD/3sKlz+hZDoOQUozeU",
	"QXswUW1k3LFa2MPK/UrEI4jywFrjjYQizbEecy082ulnEAaSmwbaJTZ4EAsGJXuMPtcHKHAJyyFcgLCR",
	"AGlazkszLGEZ1xjkUWN6ATewB8ggp31i/mB4HJJiujQ/HOR5faQK0Tb2Noz3umfXdM+CyhXJJIZoLQqo",
	"k5SIgmL4VGajO7MSvvudRM5H4W7MXW+a3UtEwFTrFnLqYNb50lCdsRawRgBHTkr28Gp12bgvjRNxOeN2",
	"UnIfi1HTQjc21on2kIjgrgBD0ibo0i4VZJnxRoxOCm2YyEi58AcA8t1zuPO1arsjB9iGA08ccGzmUkgt",
	"BU9pDifdED/gBoVq3Ay5I4ymswpf4bY5Yg+qL1nW2lTKsNI3TYRfyRyvYdO8zOqtOYYhXtRFvbFkdJXA",
	"Y39OBIe7bPZzSXPvWLZRX37VVSnvCVUstmGIjArlw5QSkdPaKaovoBFKb1kHB73AaElZTJStae5wwRUp",
	"2E8Q1Wb0lJynzNZyRNUvenZ0Sl68JAcLw5y274924YqGayhLYZUScyaDIJL9aHe0N/oGQhsWTNAFj/aj",
	"r0a7o6+Mdkb1DBSzndFoB0l6h5aGR2he5YKcsw6F/HumSb2pWTrcwLWK2vqA7qMMex7UOh66bLfCKpUA",
	"0v3dXWtTa1cne7HIbZednxTCVoUFrbQswwL/oN6107zc5GQis2WlItRBJceda4QoNK4Imy/0kvApERKQ",
	"Q3hV4dfs6Yc4eniNy2rk9LTX5RwZGB43AoValfM5LZZX3EJNz5VRwZ+BClhEb8xQO3XvRCedPGE6nQXs",
	"P7beeOAkU55rd0eFlTgKcvSoRTFPudKHtfwyWtA503Dl8XpA7VUvOCOj2Ef7ERTEcPFX+xHcKlY4b943",
	"ri03vxYE5zjomtza9tX066Z784kn5VoSF9vE9tTe2ASivmC64MxwwTCA0wz2YPfBAJitFAVgXc3UCqlH",
	"j8CmpHnJGsVp66XIouybrx9MvmX3t/e+nd7ffvDwm/vbE3p/d/uPkwf3v36wN9n9Jn3QLC/r5qucUcF9",
	"RQcwPCNbQ+bZgkPY7u+M+67lWEIpsRO+Y9ID7nMkpgpSo4tAJAQKZjhl4UCQOSekJlNZigz39Zq4z4l3",
	"A9aXiaecZJLhzOBuafCmzdiG41IBs3jzIY4WssuldNhbKbDOfcKaeRE6JJjS38lseW2MvKvI4Ye698P6",
	"g29MRLYqA3ZsaFWdMDzOLn6wKV768du5TXV5svM+PMMfcPegLmhH7Wnze81Fv2I3sXW4oZsKE8fOjRJV",
	"cfPW40PhBq4SMgO5fB28tHtHEFWocDwYRCS+ulmN8dgc44iLC5rzjKQzWtBUs2KfsHcLTL+gwh9NY2NN",
	"+TsjBMZlIfbNyvbH9tIej+vr3e1v6fb0YPvJ9psYeQ4ZizGhmuwZrRW5XySkPqNngJkmoztCWF6VPDum",
	"mGRecTv7kbx6dfTIVQDfqgbb2idbn2ctW9HN8lGe+UcSCK7HADi6smj9TQnOm8ZoXSI1+dk6PtMjfFZo",
	"xaErcLIkR49GXcbSb5dXXYtgaiqiq8RSt755ywb/9dhghzLZedr6NEZ4caOtMmLB9foTPhiIEl7myY7K",
	"/fVj3Yhy+MJP9vUrvD3BNZ9Z5+2KNekgvB4lCy87b2XuTcrcTzhwvUaGv0BY47MKbjjX2p6jTp/VsZ9p",
	"2PlulOj6jJ6qVoTLb8dR5au9DnBR+TI6EF3cqy10CI+rEoOjvooEBjoiwuiylh/iuKq3dUNuiGZs3Of3",
	"QtSil1btYY8P4lp8i+1NehE8hhIyMOXqJVv+Ff+2HZJBUbk+9h1cujVceN1rD2Pjoq+/YQ8f7j54sL23",
	"O9nbfnD/6+n2t/cffLM9mXz9x132cMp20z/2rfzYV5VrrzsAamvIHFs35OkM4ECh1EsoK5xlIQ/oYiQ1",
	"KVaPixjiKAvuYmslRuB6dcLc5aevpYSVHVr8qCpIaN/ruaKIW63B1utl3rAbrZunbOxFg4mcDebH7r+u",
	"uLUvP8G+DKrnwQW6LdfRv8cpFeYYTpjbYIIhGFUNSOKqhNQDKaAgSy+Hb5SDDOqGNCs9Bp/czh8iTJk7",
	"oS5MozqpK0BqFYHZ8qWyturP0oXldKP77Jtv6ZTtbU+nD7LtBw+yr7bp9OF0+9uvvv0mY9988+DrdLdS",
	"NAL4jdrXIpc8Z+c0D+sYslNfQq1+I5W66nZgt+Mxsnnvayvw7JPPgarrlA3B+TdrdudCFvXQtLxgNFu6",
	"1XyyUbnBVvdJ3Urn7BC7FTsnW0NmuRmLMgRjmBN3YxnYrdivdPL6wft9vAGSf0tSdDhp1lOpMQ8yKNsC",
	"OWLbp3L71D1hXz197bJqDNupHFzqov+p671d+F/sX36J5sszmOzMPShSe2w5yNsptRzJ6VQxPSqYMrsa",
	"MVrknIF6e17IcjHyddvhbMFvhlFqueAp0IZmSuN8e0AdFmZITkNCXpESvtufXr3b2tftQfp0raoNpu4Z",
	"XP/A2eWNoBpnO7sw4382VN/vQbXPjf7jYM5TuRRWsPOqetfqa4dbHn5FHt4KDelz57f5ao/XZY0z343T",
	"5VqMIWco7gj3qyXdvfAl6mIMj537Io/B6C5UdLIke313Ar8JSXBTFwK/svepI31usANq49uA329w22K9",
	"5fsFs7gPN8rkGs6hodcgn8yqru5R2qlE9iAtd0s17mKgHvCMCXwduZ7ZENu4eOWrR9oI5NBHkIhxLVN6",
	"XKU6+lwQeKTN5a9AzpYL0vBv9EnMZ8PUHhf4H5oB4dt+TqTb2qv32LsFFRnL7tlV6DDkv2flmNwBYYwu",
	"pQ/q80L2U2NFLofOVTxPRDVPVdC++z3ZXmvCB9b/jmyKq2lwLrW+fSYf2w3tqwp1q9P9qjpdi4tswLiw",
	"EjK+BtPJul5CtaHQ6QReX+zVSuypHoycEiqWqxzidt7f6cEbWN6g+X5UV5WDdhIBVXrtFvQcTnLHlY8y",
	"05htqj0PI9gFlBmzYy+Zvnt7nK90nMfBcsdrDvQnn62rnnZMCN55Dx4eSG2Ay7DuK/eTcoKvwWD9gurJ",
	"X1TjbU419VnVkCdpBvZlywJahBc7lMtKrwrzB8Pa4udO6/AFUhJRq/8YEwalJjJS+tRTW+OsqqliXZPj",
	"f8Mv//84EZ7NjMgruwAokb/IuSZcaEnGh7NSvB1vqfYCQoCxWq7HQvBCi818zqXC3GKvVtn4m9r55Ao8",
	"pwSelWnxyT9rvUAv1OYccnSzLDLuKnNb26p6pEwdiooEVwKxdlL7qCVk0CPEruDVVqoutgwoW4Y/bfVF",
	"7NhlfhIQ8Kg0KtRQ54BIUdX9HpFn1mEuBdzVbMHPWzHZCp9s3gIzZMs/27yFXndbhpKAZWiIxvbuWY37",
	"86qSKHwcu7PUTg/e5zLrWOAl1ekMca8EXaiZ1L3LwbY9y5ljIf+rruYx8LlnpvOgxTypY949yI3PoAhf",
	"H9K3MFuNDtyeVe3t7o56d8i9y9152LpqTPbEkAU1J1tHkUHW+Ni0h5o94Bb2PIvbN2Ms8wXuB8UiISpM",
	"kTtQaIODe+OnUiADA949tgzVHKnx3Z7Vj+HuYtyDAIw8GxAjV5Ub/ASH2jCCeR4cxP5D0BL7P7oHx8aw",
	"xjHxnBrYO25C85Sb9pA/bQW7y2yfY5FtyKmGIJeql5NsqdXzb9LBB0JwRQpB8ECb9wTUNEymDIfiasYy",
	"pI/6Ym0GefWeaaACYOkXA4C6QkTJNelwTpEMRElbo9hyGsUWocV5OWdwFT5UQb52bbMublvaZhw92Nv9",
	"NRV3H+tQPSlTae7eSTxkaBcLUSnKYRjAdcch9E1GJiyFx8e4Dh7e8Q/qFdAreAHiSytnsLlOv4G1YYsU",
	"DTQ3jks188W6aFX3vaqDjeq10b8VNvxEQ4BACaEOVmzfFbMb5l2LMCdw6bnRWdDrWSm9uEX1ucfV0sct",
	"owKrQdm1UGVoihYFv2BoJ8lSQylzszbnzGUiC0oROWBPPPuFAlIVk7UPPbmCSzTPcTJHuolAGFoevC5z",
	"BOIPfovWyGewQkARQG0rhvLsnpJrNh+7YII0aw9xRfClr420KXjUcwjwQfHm9uM3v74JVddY+bRPVzU2",
	"+4Kmb+k5nLDrU1xVgOvR9amurYX6B52swwOIQjvONXwBPeYUF4oV+gxD/3p3DJF75jfuqvryvysp0Ivy",
	"BIfoUpdXau2avdM7qbqoi74mmXQpobYsoa3IFVQB5IIcnvwwigZeh3dUzm6GNvMLyFxp3oN9dtW0Xvm+",
	"WvKX4Ju9VfG+LBWvV4/aQINTmmq16moIbhiCyFDzS2prEOLD01BB0r7IoPrvg05gpt/pZVCjEO8KonQI",
	"vE3S/5dI0g/vrG6iVMlthHvvxdsGnOuq3BM2kmKWWScD/cE2aBZ4PZyx9K0ilzOmZ6yoVa8NayXiW/gp",
	"1FPFSq5Y9lMlIjUjmMPixmhcDfsgIEduvnRzWHS16lqrV2c7255Yc3kHnzN1b137QaAktixWpMY5JPzO",
	"mX+/ShtQwXE9zuZ6s+o2ZkLxbULeDSTkOXDqLlx/ujpisbvOIMVu4N5xj0yvzLKec6jYHO2/fh3R1Lk+",
	"5kvMRHjzponSH8y5fi71kbCvHneq943XAi1tVZlcnn/Yp1wB6AXlhSJbFgr/yquFZWsfLFzzzzvqLsmk",
	"X1qDy3Rg8+pYxH7XgEZMnmnjEZJ2rh+RCHc/JvGyGFEJ/x6Ay+PgAeHwFWV8Zq7jlaygpHOzyHVd7lCu",
	"/KvIwZjdSMYEm7qtibPgq/Kn0j6qV8NkDZjgdYMaIBnP0PizVbXrlVcDFASNsqsunKt6tXpMqGXCD3jV",
	"ZT+X+tDBcuUl29epawAYM3bUWq/qUlWqlB6nWGFleT+xYnqD9Zww3V7KuqncGq81/twxkIaT51b3vm7d",
	"u0vp3UC5fk/BN7riQskmBMDNDWaXd6dLV0+7+Pvs4PUGeHQACvDDK6x4C4NZ8B2xeYmYLNGvC446rRpT",
	"U60LPik1I3fcGx8ZV2mpwkg/2yUR2GcuM5Y7Pv16HHpMSjV+QzKZwj00EOVdf10WhulDwCefz1lmOFS+",
	"JHSqWUGsgeIuz1wggtHZp7K4pEWGjyXorkwA394urlTOoe3i8xWhainSWSGFLFW+bOSA1W9GwMoKwWBZ",
	"HXcjQl5YeRFjcJ3vrH0SvY8eHKOMGLu+p/6Z/pQKMpeCa3ulFqbSl6oVRjtZkoXM/Rv+4+8fnybCU+W4",
	"Soh3eK+eX7XXCnbEMRLs2McNwFUGTVO20O4JhIAG9/GhuS3wMm7tkxN46WFRSPfkBvh/oQncHm3tk2Nw",
	"WzZI2wzhsvf3ySkr5lwYqlpJx/3WGhYm+FJttbhXbCHyyWtAZ4wXbrF3677pBou6xQ6/12pbi/f73050",
	"m7+hnWeLRFS1OqBDl6LySeUkBlfzOJmV8Er4I7wFaJX0CG4IGjU9CoYPmdTf44GKI1y7SFl8K1ReihH5",
	"0b3wXas/YJ9JgeIF9gGd4KEYvCyqnjRqLvGaCn/4wiW/evWPXx+poWF264z4LTgjLMfbf9+jHVs26mNc",
	"erbDDWMMYvvvHuy05EobRYsGD9/yg279iYRgQUD/PtnCDIqt2AnP2IlIjLD24vDWDXPrhvmC3TAWl7eE",
	"eR2EeevTuvVp/cv5tMI6PIETwupVcPJu3VzX5+YaGgZ0bYiMI83nTJYaH8ASEutfYY2svd0PfaFaR4Jr",
	"TnP+V4Dr1I4Rov3HIO54cbUYrtrYxACYwTPP6HLa21XXuDEW9FaYdOUZkhVArKdiyHoH4Sr3pH12dV2d",
	"dNtsozLp3zN97KYZ6HjxFXZ/pVf9HADXWiq9nYO4cNlI4YOn9YfCM2Zj9hJh1YJj//roTyzVyvpHq1dI",
	"AcxRIo6mBKKByR0bZXs3tv5J235RGygRlzzPgSGE0BgI+jBghCqezatnw914yXhc3OCXDR2FXltRkFrN",
	"J4fqFVWSvtQK2q264b/vZwzDRXY+YtjzdsDVGKRnx44vDn05wL4L3flwgN/4m3o3ACe4UuG2vRsBoKdo",
	"m2Oa+E5Ax3uk326o3XToy49K7MrWkTEYHfjAu63/C2R0nWrEgafalTM2X7xeXZ++orQOYg1Vh533Fe8a",
	"WJvejp2IRMCPRgpODaptclGB9ZI1yRlVGtLyKy9a25r1r5D3PQVZHY3NtI+eW5+KZd989Xpn0l1/8XoA",
	"a9hbELce7c9X795hXZBSseH7411nME8Vo3BjD3dYQI/EK8W+W3YawcdXVTuwiLpZeGMRN/6gxwoM2vff",
	"rz/I/QvV/G4W0UNLuK8UQ+uKstvpVtRk/5IFw629eD324nAzsV+nvKlSkbdnv79MZPP0dhtNKwt/y+BF",
	"LzmtBoXSk1n7hUHw9xi19Kjd2BV4iwkVSyLFucTngauLk3OmFUmpSFmesyzGMgfeGY/xWSBgbGWd8XMp",
	"2Dj2hWFdU1s5LxGYE4OVxvHA7tkEGxuhJ0W+DLvamsFmKeHKPMLpdMpSTbhWifD1+QpfldYtxIZp9dYv",
	"/+LV6RsrXr6BCbx7UzCstoJtsfJbfnUD/OrWl7DWl/AJ/PeKLocde3XaH0n9jBZvA4EyhXLpnts1C/Sk",
	"VBBd0PRtA9yKPVpWbkNrXWxtIsYOwBp8Y7Mw/0lVIbcgSTKQEoL4jEeItcUZxmTKWZ75+5ya/tXizfYe",
	"+l+ROdeXfiXufL8rEKXaahdTrsrJnOvreAr6loV+Mgt9H+UUHgWyKky0/7CJoxelBvFnkfSDbRjiyjVp",
	"ql0j8hRGd3/vk62H14mf4/p07WJfjuZcvBNU64IvuOwmwOt48Rr218NuzRCsuHDcoyzyaD/audiFUjm2",
	"Q0cIF+Z2E7VUms3JhM3oBYe3RywjeUYFhaKfcZtLmy/+JqXq4qHq7xM8wu06+Z96e2ERo+rpcN83eE78",
	"w5sP/y8AAP//JRsnq1DyAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
